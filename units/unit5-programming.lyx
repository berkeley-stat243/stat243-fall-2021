#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{/accounts/gen/vis/paciorek/latex/paciorek-asa,times,graphics}
\input{/accounts/gen/vis/paciorek/latex/paciorekMacros}
%\renewcommand{\baselinestretch}{1.5}
\hypersetup{unicode=true, pdfusetitle,
bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true,}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

setup, include=FALSE
\end_layout

\end_inset

if(exists('format.bytes')) rm(format.bytes)
\end_layout

\begin_layout Plain Layout

library(knitr) 
\end_layout

\begin_layout Plain Layout

library(pryr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.path = 'figures/listings-') 
\end_layout

\begin_layout Plain Layout

options(replace.assign = TRUE, width = 55) 
\end_layout

\begin_layout Plain Layout

read_chunk("unit5-programming.R")
\end_layout

\end_inset


\end_layout

\begin_layout Title
Unit 5: Programming concepts, illustrated with R
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
2022: could refer to sys and processx packages as better ways to interact
 with the OS: https://www.r-bloggers.com/2021/09/how-to-use-system-commands-in-you
r-r-script-or-package/
\end_layout

\begin_layout Plain Layout
2022-06-17: mention Julia multiple dispatch when do R generic-function OOP
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
2021: not sure what this refers to but perhaps to where I note areas for
 improved efficiency: some code that could be more efficient - don't need
 full pertub alloc; inverse, order of ops 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
use lobstr for memory use, copying etc? 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that in this material, I often sneak an extra trick into my example
 code.
 Focus first on the key thing I'm illustrating and then you might absorb
 the extra trick.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This unit covers a variety of programming concepts, illustrated in the context
 of R.
 So it also serves as a way to teach advanced features of R.
 In general the concepts are relevant in other languages, though other languages
 may implement things differently.
 One of my goals here for us to think about why things are the way they
 are in R.
 I.e., what principles were used in creating the language and what choices
 were made? While other languages use different principles and made difference
 choices, understanding what R does in detail will be helpful when you are
 learning another language.
\end_layout

\begin_layout Standard
References: 
\end_layout

\begin_layout Itemize
Books on R listed on the syllabus: Adler, Chambers, Wickham
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "R intro manual"
target "http://cran.r-project.org/doc/manuals/R-intro.html"
literal "false"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "R language manual"
target "http://cran.r-project.org/doc/manuals/R-lang.html"
literal "false"

\end_inset

 (R-lang), both on CRAN.
\end_layout

\begin_layout Itemize
Venables and Ripley, Modern Applied Statistics with S
\end_layout

\begin_layout Itemize
Murrell, Introduction to Data Technologies
\end_layout

\begin_layout Standard
I'm going to try to refer to R syntax as 
\emph on
statements
\emph default
, where a statement is any code that is a valid, complete R expression.
 I'll try not to use the term 
\emph on
expression
\emph default
, as this actually means a specific type of object within the R language,
 as seen in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Computing-on-the"

\end_inset

.
 
\end_layout

\begin_layout Section
Interacting with the operating system from R and controlling R's behavior
\end_layout

\begin_layout Standard
I'll assume everyone knows about the following functions/functionality in
 R:
\end_layout

\begin_layout Standard

\emph on
getwd(), setwd(), source(), pdf(), save(), save.image(), load()
\end_layout

\begin_layout Itemize
To run UNIX commands from within R, use 
\emph on
system()
\emph default
, as follows, noting that we can save the result of a system call to an
 R object:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

system
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
There are also a bunch of functions that will do specific queries of the
 filesystem, including
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

file-commands, eval=TRUE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
There are some tools for dealing with differences between operating systems.
 Here's an example:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

list-files
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To get some info on the system you're running on:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

sys-info
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To see some of the options that control how R behaves, try the 
\emph on
options()
\emph default
 function.
 The 
\emph on
width
\emph default
 option changes the number of characters of width printed to the screen,
 while the 
\emph on
max.print
\emph default
 option prevents too much of a large object from being printed to the screen.
 The 
\emph on
digits
\emph default
 option changes the number of digits of numbers printed to the screen (but
 be careful as this can be deceptive if you then try to compare two numbers
 based on what you see on the screen).
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

options
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Use 
\family typewriter
Ctrl-C
\family default
 to interrupt execution.
 This will generally back out gracefully, returning you to a state as if
 the command had not been started.
 Note that if R is exceeding memory availability, there can be a long delay.
 This can be frustrating, particularly since a primary reason you would
 want to interrupt is when R runs out of memory.
\end_layout

\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "R mailing list archives"
target "http://tolstoy.newcastle.edu.au/R/"
literal "false"

\end_inset

 are very helpful for getting help - always search the archive before posting
 a question.
 More info on where to find R help in Unit 5 on debugging.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
sessionInfo()
\emph default
 gives information on the current R session - it's a good idea to include
 this information (and information on the operating system such as from
 
\emph on
Sys.info()
\emph default
) when you ask for help on a mailing list
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

sessionInfo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Any code that you wanted executed automatically when starting R can be placed
 in 
\emph on
~/.Rprofile
\emph default
 (or in individual 
\emph on
.Rprofile
\emph default
 files in specific directories).
 This could include loading packages (see below), sourcing files that contain
 user-defined functions that you commonly use (you can also put the function
 code itself in 
\emph on
.Rprofile
\emph default
), assigning variables, and specifying options via 
\emph on
options()
\emph default
.
\end_layout

\begin_layout Itemize
You can have an R script act as a shell script (like running a bash shell
 script) as follows.
 This will probably on work on Linux and Mac.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Write your R code in a text file, say 
\emph on
exampleRscript.R
\emph default
.
 
\end_layout

\begin_layout Enumerate
As the first line of the file, include 
\family typewriter
#!/usr/bin/Rscript
\family default
 (like 
\family typewriter
#!/bin/bash
\family default
 in a bash shell file, as seen in Unit 2) or (for more portability across
 machines, include 
\family typewriter
#!/usr/bin/env Rscript
\family default
.
 
\end_layout

\begin_layout Enumerate
Make the R code file executable with 
\emph on
chmod
\emph default
: 
\family typewriter
chmod ugo+x exampleRscript.R
\family default
.
\end_layout

\begin_layout Enumerate
Run the script from the command line: 
\family typewriter
./exampleRscript.R
\end_layout

\begin_layout Standard
If you want to pass arguments into your script, you can do so as long as
 you set up the R code to interpret the incoming arguments:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

rscript-args, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

rscript-run, engine='bash'
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Text manipulation, string processing and regular expressions (regex)
\end_layout

\begin_layout Standard
Text manipulations in R have a number of things in common with Python, Perl,
 and UNIX, as many of these evolved from UNIX.
 When I use the term 
\emph on
string
\emph default
 here, I'll be referring to any sequence of characters that may include
 numbers, white space, and special characters, rather than to the character
 class of R objects.
 The string or strings will generally be stored as R character vectors.
\end_layout

\begin_layout Subsection
String processing and regular expressions in R
\end_layout

\begin_layout Standard
For material on string processing in R, see the tutorial, 
\begin_inset CommandInset href
LatexCommand href
name "String processing in R and Python"
target "https://github.com/berkeley-scf/tutorial-string-processing"
literal "false"

\end_inset

.
 (You can ignore the sections on Python.) That tutorial then refers to the
 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "Using the bash shell"
target "https://github.com/berkeley-scf/tutorial-using-bash"
literal "false"

\end_inset


\emph default
 tutorial for details on regular expressions, which we discussed as part
 of the end of Unit 3.
 Finally, to test out regular expression syntax see 
\begin_inset CommandInset href
LatexCommand href
name "this online tool"
target "https://regex101.com/"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
In class we'll work through the string processing tutorial, focusing in
 particular on the use of regular expressions with the 
\emph on
stringr
\emph default
 package.
\end_layout

\begin_layout Subsection
Regex/string processing challenges
\end_layout

\begin_layout Standard
We'll work on these challenges in class in the process of working through
 the string processing tutorial.
\end_layout

\begin_layout Enumerate
What regex would I use to find a spam-like pattern with digits or non-letters
 inside a word? E.g., I want to find "V1agra" or "Fancy repl!c@ted watches".
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[[:alpha:]][[:digit:][:punct:]][[:alpha:]]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
How would I extract email addresses from lines of text using regular expressions
 and R string processing?
\begin_inset Note Note
status open

\begin_layout Plain Layout
[^[:alnum:]][[:alnum:]][_
\backslash

\backslash
.[:alnum:]]*@([_
\backslash

\backslash
.[:alnum:]]+
\backslash

\backslash
.){1,3}[_
\backslash

\backslash
.[:alnum:]]+[^[:alnum:]]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Suppose a text string has dates in the form 
\begin_inset Quotes eld
\end_inset

Aug-3
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

May-9
\begin_inset Quotes erd
\end_inset

, etc.
 and I want them in the form 
\begin_inset Quotes eld
\end_inset

3 Aug
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

9 May
\begin_inset Quotes erd
\end_inset

, etc.
 How would I do this search and replace operation? (Alternatively, how could
 I do this without using regular expressions at all?) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
str_replace_all(text, 
\begin_inset Quotes eld
\end_inset

(Jan|Feb|...|Dec)-([[:digit:]]{1,2})
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\backslash

\backslash
2 
\backslash

\backslash
1
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
How would I search for numeric URLs such as in the file 
\emph on
urls.txt
\emph default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
see regExpExample.q
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Side notes on special characters in R 
\end_layout

\begin_layout Standard
Recall that when characters are used for special purposes, we need to escape
 them if we want them interpreted as the actual character.
 In what follows, I show this in R, but similar manipulations are sometimes
 needed in the shell and in Python.
\end_layout

\begin_layout Standard
This can get particularly confusing in R as the backslash is also used to
 input special characters such as newline (
\backslash
n) or tab (
\backslash
t).
 (Note that it is hard to get the PDF to compile correctly for these R chunks,
 so I am just pasting in the output from running in R 'manually'.)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<escape1, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a result in R, we often need two backslashes when working with regular
 expressions.
 In these examples, the first backslash says to interpret the next backslash
 literally, with the second backslash being used to indicate that the caret
 (^) should be interpreted literally and not as a special character used
 for specifying regular expressions.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<escape2, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Challenge: explain why we use a single backslash to get a newline and double
 backslash to write out a Windows path in the examples here:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<escape-challenge>>=
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For more information, see 
\family typewriter
?Quotes
\family default
 in R and the subsections of the string processing tutorial that discuss
 backslashes and escaping.
 
\end_layout

\begin_layout Standard
Advanced note: Searching for an actual backslash gets even more complicated,
 because we need to pass two backslashes as the regular expression, so that
 a literal backslash is searched for.
 However, to pass two backslashes, we need to escape each of them with a
 backslash so R doesn't treat each backslash as part of a special character.
 So that's four backslashes to search for a single backslash.
 Yikes.
 One rule of thumb is just to keep entering backslashes until things works!
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<escape3, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Be careful when cutting and pasting from documents that are not text files
 as you may paste in something that looks like a single or double quote,
 but which R cannot interpret as a quote because it's some other ASCII quote
 character.
 If you paste in a 
\begin_inset Quotes eld
\end_inset

 from PDF, it will not be interpreted as a standard R double quote mark.
\end_layout

\begin_layout Standard
Similar things come up in the shell and in Python, but in the shell you
 often don't need two backslashes.
 E.g.
 you could do this to look for a literal ^ character.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<bash, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

grep '
\backslash
^' file.txt
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
pystr for python like strings (actually removed from CRAN...)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Packages and namespaces
\end_layout

\begin_layout Standard
One of the killer apps of R is the extensive collection of add-on packages
 on 
\begin_inset CommandInset href
LatexCommand href
name "CRAN (www.cran.r-project.org)"
target "www.cran.r-project.org"
literal "false"

\end_inset

 that provide much of R's functionality.
 To make use of a package it needs to be installed on your system (using
 
\emph on
install.packages()
\emph default
 once only) and loaded into R (using 
\emph on
library()
\emph default
 every time you start R).
 
\end_layout

\begin_layout Standard
Some packages are 
\emph on
installed
\emph default
 by default with R and of these, some are 
\emph on
loaded
\emph default
 by default, while others require a call to 
\emph on
library()
\emph default
.
 For packages I use a lot, I install them once and then load them automatically
 every time I start R using my 
\emph on
~/.Rprofile
\emph default
 file.
 
\end_layout

\begin_layout Standard
If you want to sound like an R expert, make sure to call them 
\emph on
packages
\emph default
 and not 
\emph on
libraries
\emph default
.
 A 
\emph on
library
\emph default
 is the location in the directory structure where the packages are installed/sto
red.
 
\end_layout

\begin_layout Paragraph
Loading packages
\end_layout

\begin_layout Standard
You can use 
\emph on
library()
\emph default
 to either (1) make a package available (loading it), (2) get an overview
 of the package, or (3) (if called without arguments) to see all the installed
 packages.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

library
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you run 
\family typewriter
library()
\family default
, you'll notice that some of the packages are in a system directory and
 some are in your home directory.
 Packages often depend on other packages.
 In general, if one package depends on another, R will load the dependency,
 but if the dependency is installed locally (see below), R may not find
 it automatically and you may have to use 
\emph on
library()
\emph default
 to load the dependency first.
 
\emph on
.libPaths()
\emph default
 shows where R looks for packages on your system and 
\emph on
searchpaths()
\emph default
 shows where individual packages are loaded from.
 Looking the help info for 
\emph on
.libPaths()
\emph default
 gives some information about how R decides what locations to look in for
 packages.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

libpaths
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Installing packages
\end_layout

\begin_layout Standard
If a package is on CRAN but not on your system, you can install it easily
 (usually).
 You don't need root permission on a machine to install a package (though
 sometimes you run into hassles if you are installing it just as a user,
 so if you have administrative privileges it may help to use them).
 Of course in RStudio, you can install via the GUI.
 If you are installing by specifying the 
\emph on
lib
\emph default
 argument, you'd generally want to use whatever user-owned directory (i.e.,
 library) is specified by the output of 
\emph on
.libPaths()
\emph default
.
 If none of them are user-owned, you may need to add a library via .libPaths()
 (e.g., by putting something like 
\family typewriter
.libPaths('~/Rlibs')
\family default
 in your 
\emph on
.Rprofile
\emph default
).
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

install, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that R will generally install the package in a reasonable place if
 you omit the 
\emph on
lib
\emph default
 argument.
 
\end_layout

\begin_layout Standard
You can also download the zipped source file from CRAN and install from
 the file; see the help page for 
\emph on
install.packages()
\emph default
.
 This is called 
\begin_inset Quotes eld
\end_inset

installing from source
\begin_inset Quotes erd
\end_inset

.
 On Windows and Mac, you'll need to do something like this:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

install-source, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you've downloaded the binary package (files ending in .tgz for Mac and
 .zip for Windows) and want to install the package directly from the file,
 use the syntax above but omit the 
\family typewriter
type='source'
\family default
 argument.
\end_layout

\begin_layout Standard
The difference between the source package and the binary package is that
 the source package has the raw R (and C and Fortran, in some cases) code
 as text files while the binary package has all the code in a binary/non-text
 format, including any C and Fortran code having been compiled.
 To install a source package with C or Fortran code in it, you'll need to
 have developer/command-line tools (e.g., 
\emph on
XCode
\emph default
 on Mac or 
\emph on
Rtools.exe
\emph default
 on Windows) installed on your system so that you have a compiler.
\end_layout

\begin_layout Paragraph
Package namespaces
\end_layout

\begin_layout Standard
The objects in a package (primarily functions, but also data) are in their
 own workspaces, and are accessible after you load the package using 
\emph on
library()
\emph default
, but are not directly visible when you use 
\emph on
ls()
\emph default
.
 In other words, each package has its own 
\emph on
namespace
\emph default
.
 Namespaces help achieve modularity and avoid having zillions of objects
 all reside in your workspace.
 We'll talk more about this when we talk about scope and environments.
 If we want to see the objects in a package's namespace, we can do the following
:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

namespace
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Types, classes, and object-oriented programming
\end_layout

\begin_layout Subsection
Types and classes
\end_layout

\begin_layout Standard
You should be familiar with vectors as the basic data structure in R, with
 character, integer, numeric, etc.
 classes.
 Vectors are either 
\emph on
atomic vectors
\emph default
 or 
\emph on
lists
\emph default
.
 Atomic vectors generally contain one of the four following types: 
\emph on
logical
\emph default
, 
\emph on
integer
\emph default
, 
\emph on
double/numeric
\emph default
, and 
\emph on
character
\emph default
.
\end_layout

\begin_layout Standard
Objects in general have a type, which relates to what kind of values are
 in the objects and how objects are stored internally in R (i.e., in C).
 
\end_layout

\begin_layout Standard
You can look at Table 7.1 in the Adler book to see some other types.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

typeof
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Everything in R is an object and all objects have a class.
 For simple objects class and type are often closely related, but this is
 not the case for more complicated objects.
 The class describes what the object contains and standard functions associated
 with it.
 In general, you mainly need to know what class an object is rather than
 its type.
 Classes can 
\emph on
inherit
\emph default
 from other classes; for example, the 
\emph on
glm
\emph default
 class inherits characteristics from the 
\emph on
lm
\emph default
 class.
 We'll see more on the details of object-oriented programming shortly.
\end_layout

\begin_layout Standard
We can create objects with our own defined class (an S3 class in this simple
 example - we'll discuss S3 classes in Section 4.4.1).
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Attributes
\end_layout

\begin_layout Standard

\emph on
Attributes
\emph default
 are information about an object attached to an object as something that
 looks like a named list.
 Attributes are often copied when operating on an object.
 This can lead to some weird-looking formatting:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

attr1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus in any subsequent operations with 
\emph on
qs
\emph default
, the 
\emph on
names
\emph default
 attribute will often get carried along.
 We can get rid of it:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

attr2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A common use of attributes is that rows and columns may be named in matrices
 and data frames, and elements in vectors:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

attr3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Assignment and coercion
\end_layout

\begin_layout Standard
We assign into an object using either '
\emph on
=
\emph default
' or '
\emph on
<-
\emph default
'.
 A rule of thumb is that for basic assignments where you have an object
 name, then the assignment operator, and then some code, '
\emph on
=
\emph default
' is fine, but otherwise use '
\emph on
<-
\emph default
'.
\end_layout

\begin_layout Standard
Let's look at these examples to understand the distinction between `=' and
 `<-' when passing arguments to a function.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

assign
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
What can you tell me about what is going on in each case above?
\end_layout

\begin_layout Standard
One situation in which you want to use '
\emph on
<-
\emph default
' is if it is being used as part of an argument to a function, so that R
 realizes you're not indicating one of the function arguments, e.g.:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

assign2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here's another example:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

assign3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
R often treats integers as numerics, but we can force R to store values
 as integers:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

intL
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We convert between classes using variants on 
\emph on
as()
\emph default
: e.g., 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

as
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some common conversions are converting numbers that are being interpreted
 as characters into actual numbers, converting between factors and characters,
 and converting between logical TRUE/FALSE vectors and numeric 1/0 vectors.
 In some cases R will automatically do conversions behind the scenes in
 a smart way (or occasionally not so smart way).
 Consider these examples of implicit coercion:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

coercion
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Be careful of using factors as indices:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

factor-indices
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
What has gone wrong and how does it relate to type coercion?
\end_layout

\begin_layout Standard
In other languages, converting between different classes is sometimes called
 
\emph on
casting
\emph default
 a variable.
\end_layout

\begin_layout Standard
Here's an example we can work through that will help illustrate how type
 conversions occur behind the scenes in R.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

coercion2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Object-oriented programming
\end_layout

\begin_layout Standard
Popular languages that use OOP include C++, Java, and Python.
 In fact C++ is the object-oriented version of C.
 Different languages implement OOP in different ways.
\end_layout

\begin_layout Standard
The idea of OOP is that all operations are built around objects, which have
 a class, and methods (i.e., class-specific functions) that operate on objects
 in the class.
 Classes are constructed to build on (inherit from) each other, so that
 one class may be a specialized form of another class, extending the components
 and methods of the simpler class (e.g., 
\emph on
lm
\emph default
 and 
\emph on
glm
\emph default
 objects).
 
\end_layout

\begin_layout Standard
Note that in more formal OOP languages, all functions are associated with
 a class, while in R, only some are.
\end_layout

\begin_layout Standard
Often when you get to the point of developing OOP code in R, you're doing
 more serious programming, and you're going to be acting as a software engineer.
 It's a good idea to think carefully in advance about the design of the
 classes and methods.
 
\end_layout

\begin_layout Subsubsection
S3 approach
\end_layout

\begin_layout Standard
S3 classes are widely-used, in particular for statistical models in the
 
\emph on
stats
\emph default
 package.
 S3 classes are very informal in that there's not a formal definition for
 an S3 class.
 Instead, an S3 object is just a primitive R object such as a list or vector
 with additional attributes including a class name.
 
\end_layout

\begin_layout Paragraph
Inheritance
\end_layout

\begin_layout Standard
Let's look at the 
\emph on
lm
\emph default
 class, which builds on lists, and 
\emph on
glm
\emph default
 class, which builds on the 
\emph on
lm
\emph default
 class.
 Here 
\emph on
mod
\emph default
 is an object (an instance) of class 
\emph on
lm
\emph default
.
 An analogy is the difference between a random variable and a realization
 of that random variable.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

inherit
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Often S3 classes inherit from lists (i.e., are special cases of lists), so
 you can obtain components of the object using the $ operator.
\end_layout

\begin_layout Paragraph
Creating our own class
\end_layout

\begin_layout Standard
We can create an object with a new class as follows:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

s3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Actually, if we want to create a new class that we'll use again, we want
 to create a 
\emph on
constructor
\emph default
 function that initializes new bears:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

constructor
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For those of you used to more formal OOP, the following is probably disconcertin
g:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

s3weird
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Methods
\end_layout

\begin_layout Standard
The real power of OOP comes from defining 
\emph on
methods
\emph default
.
 For example,
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

s3methods, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here 
\emph on
summary()
\emph default
 is a generic method (or generic function) that, based on the type of object
 given to it (the first argument), dispatches a class-specific function
 (method) that operates on the object.
 This is convenient for working with objects using familiar functions.
 Consider the generic methods 
\emph on
plot()
\emph default
, 
\emph on
print()
\emph default
, 
\emph on
summary()
\emph default
, 
\emph on
`[`
\emph default
, and others.
 We can look at a function and easily see that it is a generic method.
 We can also see what classes have methods for a given generic method.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

generic
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In many cases there will be a default method (here, 
\emph on
summary.default()
\emph default
), so if no method is defined for the class, R uses the default.
 Sidenote: arguments to a generic method are passed along to the selected
 method by passing along the calling environment.
 
\end_layout

\begin_layout Standard
We can define new generic methods:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

new-generic
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once 
\emph on
UseMethod()
\emph default
 is called, R searches for the specific method associated with the class
 of 
\emph on
object
\emph default
 and calls that method, without ever returning to the generic method.
 Let's try this out on our 
\emph on
bear
\emph default
 class.
 In reality, we'd write either 
\emph on
summary.bear()
\emph default
 or 
\emph on
print.bear()
\emph default
 (and of course the generics for 
\emph on
summary
\emph default
 and 
\emph on
print
\emph default
 already exist) but for illustration, I wanted to show how we would write
 both the generic and the specific method, so I'll write a 
\emph on
summarize
\emph default
 method.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

class-specific
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
The print method
\end_layout

\begin_layout Standard
Like 
\emph on
summary()
\emph default
, 
\emph on
print()
\emph default
 is a generic method, with various class-specific methods, such as 
\emph on
print.lm()
\emph default
.
\end_layout

\begin_layout Standard
Note that the 
\emph on
print()
\emph default
 function is what is called when you simply type the name of the object,
 so we can have object information printed out in a structured way.
 Recall that the output when we type the name of an 
\emph on
lm
\emph default
 object is NOT simply a regurgitation of the elements of the list - rather
 
\emph on
print.lm()
\emph default
 is called.
\end_layout

\begin_layout Standard
Similarly, when we used 
\family typewriter
print(object.size(x))
\family default
 we were invoking the 
\emph on
object_size
\emph default
-specific print method which gets the value of the size and then formats
 it.
 So there's actually a fair amount going on behind the scenes.
\end_layout

\begin_layout Standard
Surprisingly, the 
\emph on
summary()
\emph default
 method generally doesn't actually print out information; rather it computes
 things not stored in the original object and returns it as a new class
 (e.g., class 
\emph on
summary.lm
\emph default
), which is then automatically printed, per my comment above, using 
\emph on
print.summary.lm()
\emph default
, unless one assigns it to a new object.
 Note that 
\emph on
print.summary.lm()
\emph default
 is hidden from user view.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

summary, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
More on inheritance
\end_layout

\begin_layout Standard
As noted with 
\emph on
lm
\emph default
 and 
\emph on
glm
\emph default
 objects, we can assign more than one class to an object.
 Here 
\emph on
summarize()
\emph default
 still works, even though the primary class is 
\emph on
grizzly_bear
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

inherit2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The classes should nest within one another with the more specific classes
 to the left, e.g., here a 
\emph on
grizzly_bear
\emph default
 would have some additional objects on top of those of a 
\emph on
bear
\emph default
, perhaps 
\emph on
number_of_people_eaten 
\emph default
(since grizzly bears are much more dangerous than some other kinds of bears),
 and perhaps additional or modified methods.
 
\emph on
grizzly_bear
\emph default
 inherits from 
\emph on
bear
\emph default
, and R uses methods for the first class before methods for the next class(es),
 unless no such method is defined for the first class.
 If no methods are defined for any of the classes, R looks for 
\emph on
method.default()
\emph default
, e.g., 
\emph on
print.default()
\emph default
, 
\emph on
plot.default()
\emph default
, etc..
\end_layout

\begin_layout Paragraph
Why use class-specific methods?
\end_layout

\begin_layout Standard
We could have implemented different functionality (e.g., for 
\emph on
summary()
\emph default
) for different objects using a bunch of 
\emph on
if
\emph default
 statements (or 
\emph on
switch()
\emph default
) to figure out what class of object is the input, but then we need to have
 all that checking.
 Furthermore, we don't control the 
\emph on
summary()
\emph default
 function, so we would have no way of adding the additional conditions in
 a big if-else statement.
 The OOP framework makes things 
\emph on
extensible
\emph default
, so we can build our own new functionality on what is already in R.
\end_layout

\begin_layout Paragraph
Final thoughts
\end_layout

\begin_layout Standard
Consider the 
\emph on
Date
\emph default
 class discussed in the R bootcamp.
 This is another example of an S3 class, with methods such as 
\emph on
julian()
\emph default
, 
\emph on
weekdays()
\emph default
, etc.
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: how would you get R to quit immediately, without asking for any more informati
on, when you simply type 'k' (no parentheses!) instead of '
\emph on
quit()
\emph default
'? 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hint: if you type 'k', what function is R going to use? point of confusion
 here if use q instead of k is that you define q but there is a q()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What we've just discussed are the old-style R (and S) object orientation,
 called S3 methods.
 An old, but somewhat newer style is called S4 and we'll discuss it next.
 S3 is still commonly used, in part because S4 can be slow.
 S4 is more structured than S3.
 
\end_layout

\begin_layout Subsubsection
S4 approach (optional)
\end_layout

\begin_layout Standard
S4 methods are used a lot in 
\emph on
bioconductor
\emph default
, a project that provides a lot of bioinformatics-related code.
 They're also used in 
\emph on
lme4
\emph default
, among other packages.
 Tools for working with S4 classes are in the 
\emph on
methods
\emph default
 package.
\end_layout

\begin_layout Standard
Note that components of S4 objects are obtained as 
\family typewriter
object@component
\family default
 so they do not use the usual list syntax.
 The components are called 
\emph on
slots
\emph default
, and there is careful checking that the slots are specified and valid when
 a new object of a class is created.
 You can use the 
\emph on
prototype
\emph default
 argument to 
\emph on
setClass()
\emph default
 to set default values for the slots.
 There is a default constructor (the method is actually called 
\emph on
initialize()
\emph default
), but you can modify it.
 One can create methods for operators and for replacement functions too.
 For S4 classes, there is a default method invoked when 
\emph on
print()
\emph default
 is called on an object in the class (either explicitly or implicitly) -
 the method is actually called 
\emph on
show()
\emph default
 and it can also be modified.
 Let's reconsider our 
\emph on
bear
\emph default
 class example in the S4 context.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

s4
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
S4 methods are designed to be more structured than S3, with careful checking
 of the slots.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

s4structured
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To deal with this latter issue of the user mucking with the slots, it's
 recommended when using OOP that slots only be accessible through methods
 that operate on the object, e.g., a 
\emph on
setAge()
\emph default
 method, and then check the validity of the supplied age within 
\emph on
setAge()
\emph default
.
\end_layout

\begin_layout Standard
Here's how we create generic and class-specific methods.
 Note that in some cases the generic will already exist.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

s4methods
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can have method signatures involve multiple objects.
 Here's some syntax where we'd fill in the function body with appropriate
 code - perhaps the plus operator would create a child.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<multiobject-methods, eval = FALSE>>=
\end_layout

\begin_layout Plain Layout

setMethod(`+`, signature = c("bear", "bear"), 
\end_layout

\begin_layout Plain Layout

 definition = function(bear1, bear2) { 
\end_layout

\begin_layout Plain Layout

    ## method code goes here
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As with S3, classes can inherit from one or more other classes.
 Chambers calls the class that is being inherited from a 
\emph on
superclass
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

s4inherit
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For a more relevant example suppose we had spatially-indexed time series.
 We could have a time series class, a spatial location class, and a 
\begin_inset Quotes eld
\end_inset

location time series
\begin_inset Quotes erd
\end_inset

 class that inherits from both.
 Be careful that there are not conflicts in the slots or methods from the
 multiple classes.
 For conflicting methods, you can define a method specific to the new class
 to deal with this.
 Also, if you define your own 
\emph on
initialize()
\emph default
 method, you'll need to be careful that you account for any initialization
 of the superclass(es) and for any classes that might inherit from your
 class (see help on 
\emph on
new()
\emph default
 and Chambers, p.
 360).
\end_layout

\begin_layout Standard
You can inherit from other S4 classes (which need to be defined or imported
 into the environment in which your class is created), but not S3 classes.
 You can inherit (at most one) of the basic R types, but not environments,
 symbols, or other non-standard types.
 You can use S3 classes in slots, but this requires that the S3 class be
 declared as an S4 class.
 To do this, you create S4 versions of S3 classes use 
\emph on
setOldClass()
\emph default
 - this creates a virtual class.
 This has been done, for example, for the 
\emph on
data.frame
\emph default
 class:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

s4tos3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can use 
\emph on
setClassUnion()
\emph default
 to create what Adler calls 
\emph on
superclass 
\emph default
and what Chambers calls a 
\emph on
virtual class
\emph default
 that allows for methods that apply to multiple classes.
 So if you have a person class and a pet class, you could create a 
\begin_inset Quotes eld
\end_inset

named lifeform
\begin_inset Quotes erd
\end_inset

 virtual class that has methods for working with name and age slots, since
 both people and pets would have those slots.
 You can't directly create an object in the virtual class.
\end_layout

\begin_layout Subsubsection
R6 classes
\end_layout

\begin_layout Standard
R6 classes are a somewhat new construct in R.
 They are classes somewhat similar to S4.
 Importantly, they behave like pointers (the fields in the objects are 'mutable'
).
 We'll discuss pointers in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Approaches-to-passing"

\end_inset

.
 Let's work through an example where we set up the fields of the class (like
 S4 slots) and class methods, including a constructor.
 
\end_layout

\begin_layout Standard
Here's the initial definition of the class, with both public (user-facing)
 and private (internal use only) methods and fields.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

R6class
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can add methods after defining the class (but those methods wouldn't
 be accessible to objects of the class that have already been created.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

R6method
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's just for demonstration.
 In general we would define 
\emph on
simulate
\emph default
 when we define the class originally.
\end_layout

\begin_layout Standard
Now let's see how we would use the class.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

R6use, fig.width=7, fig.height=4, eval=TRUE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A few additional points:
\end_layout

\begin_layout Itemize
As we just saw, a copy of an object is just a pointer to the original object,
 unless we explicitly invoke the 
\emph on
clone()
\emph default
 method.
\end_layout

\begin_layout Itemize
As with S3 and S4, classes can inherit from other classes.
 E.g., if we had a 
\emph on
simClass
\emph default
 and we wanted the 
\emph on
tsSimClass
\emph default
 to inherit from it:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
R6Class("tsSimClass", inherit = "simClass", ...) 
\end_layout

\end_deeper
\begin_layout Itemize
Here we see that use of private fields shields them from modification by
 users.
 In this example, the correlation matrix and the Cholesky factor U are both
 functions of the vector of times.
 So we don't want to allow a user to directly modify 
\emph on
times
\emph default
.
 Instead we force them to use 
\emph on
setTimes()
\emph default
, which correctly keeps all the fields in the object internally consistent
 (by calling 
\emph on
calcMats()
\emph default
):
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

R6access, eval=TRUE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you need to refer to methods and fields you refer to the entire object
 as either 
\emph on
self
\emph default
 or 
\emph on
private
\emph default
.
\end_layout

\begin_layout Itemize
There is a older, more complicated, slower variation on R6 classes called
 ReferenceClasses.
 See the 
\emph on
help(ReferenceClasses)
\emph default
.
\end_layout

\begin_layout Standard
More details on R6 classes can be found in the Advanced R book: 
\begin_inset CommandInset href
LatexCommand href
target "https://adv-r.hadley.nz/r6.html"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
Standard dataset manipulations
\end_layout

\begin_layout Standard
Base R provides a variety of functions for manipulating data frames, but
 now many researchers use add-on packages (many written by Hadley Wickham
 as part of a group of packages called the 
\emph on
tidyverse
\emph default
) to do these manipulations in a more elegant, often more efficient way.
 Module 5 of the R bootcamp describes some of these new tools, but I'll
 summarize them here.
\end_layout

\begin_layout Subsection
split-apply-combine
\end_layout

\begin_layout Standard
Often analyses are done in a stratified fashion - the same operation or
 analysis is done on subsets of the data set.
 The subsets might be different time points, different locations, different
 hospitals, different people, etc.
 
\end_layout

\begin_layout Standard
The split-apply-combine framework is intended to operate in this kind of
 context: first one splits the dataset by one or more variables, then one
 does something to each subset, and then one combines the results.
 The 
\emph on
dplyr
\emph default
 package implements this framework (as does the 
\emph on
pandas
\emph default
 package for Python).
 One can also do similar operations using various flavors of the 
\emph on
apply()
\emph default
 family of functions such as 
\emph on
by()
\emph default
, 
\emph on
tapply()
\emph default
, and 
\emph on
aggregate()
\emph default
, but the dplyr-based tools are often nicer to use.
\end_layout

\begin_layout Subsection
Long and wide formats
\end_layout

\begin_layout Standard
Finally, we may want to convert between so-called 'long' and 'wide' formats,
 which we can motivate in the context of longitudinal data (multiple observation
s per subject) and panel data (temporal data for each of multiple units
 such as in econometrics).
 The wide format has repeated measurements for a subject in separate columns,
 while the long format has repeated measurements in separate rows, with
 a column for differentiating the repeated measurements.
 The wide format is useful for doing separate analyses by group, while the
 long format is useful for doing a single analysis that makes use of the
 groups, such as ANOVA or mixed models or for plotting, such as with 
\emph on
ggplot2
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

long-wide
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are a variety of functions for converting between wide and long formats.
 I recommend 
\emph on
pivot_longer()
\emph default
 and 
\emph on
pivot_wider()
\emph default
 from recent versions of the 
\emph on
tidyr
\emph default
 package.
 There are also older 
\emph on
tidyr
\emph default
 functions called 
\emph on
gather()
\emph default
 and 
\emph on
spread()
\emph default
.
 There are also the 
\emph on
melt()
\emph default
 and 
\emph on
cast()
\emph default
 in the 
\emph on
reshape2
\emph default
 package.
 These are easier to use than the functions in base R such as 
\emph on
reshape()
\emph default
 or 
\emph on
stack()
\emph default
 and 
\emph on
unstack()
\emph default
 functions
\emph on
.
\end_layout

\begin_layout Subsection
Non-standard evaluation and the tidyverse
\end_layout

\begin_layout Standard
Many tidyverse packages use non-standard evaluation to make it easier to
 code.
 For example in the following dplyr example, you can refer directly to 
\emph on
country
\emph default
 and 
\emph on
unemp
\emph default
, which are variables in the data frame, without using 
\family typewriter
data$country
\family default
 or 
\family typewriter
data$unemp
\family default
 and without using quotes around the variable names, as in 
\family typewriter

\begin_inset Quotes eld
\end_inset

country
\begin_inset Quotes erd
\end_inset


\family default
 or 
\family typewriter

\begin_inset Quotes eld
\end_inset

unemp
\begin_inset Quotes erd
\end_inset


\family default
.
 Referring directly to the variables in the data frame is not standard R
 usage, hence the term 
\begin_inset Quotes eld
\end_inset

non-standard evaluation
\begin_inset Quotes erd
\end_inset

.
 One reason it is not standard is that country and unemp are not themselves
 independent R variables so R can't find them in the usual way (see Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Variable-scope"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

dplyr-example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This 'magic' is done by capturing the code expression you write and evaluating
 it in a special way in the context of the data frame.
 I believe this uses R's environment class (discussed in Section 6), but
 haven't looked more deeply.
 
\end_layout

\begin_layout Standard
While this has benefits, this so-called non-standard evaluation makes it
 harder to program functions in the usual way, as illustrated in the following
 code chunk, where neither attempt to use the function works.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

dplyr-nse
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For more details on how to avoid this problem when writing functions that
 involve tidyverse manipulations, see 
\begin_inset CommandInset href
LatexCommand href
target "https://dplyr.tidyverse.org/articles/programming.html"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Note that the tidyverse is not the only place where non-standard evaluation
 is used.
 Consider this 
\emph on
lm()
\emph default
 call:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

lm-nse, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where is the non-standard evaluation there?
\end_layout

\begin_layout Section
Functions, frames, and variable scope
\end_layout

\begin_layout Standard
R is a functional programming language.
 All operations are carried out by functions including assignment, various
 operators (such as addition, subtraction, etc.), printing to the screen,
 etc.
\end_layout

\begin_layout Standard
Functions are at the heart of R.
 In general, you should try to have functions be self-contained - operating
 only on arguments provided to them, and producing no side effects, though
 in some cases there are good reasons for making an exception.
\end_layout

\begin_layout Standard
Functions that are not implemented internally in R (i.e., user-defined functions)
 are also referred to officially as 
\emph on
closures
\emph default
 (this is their 
\emph on
type
\emph default
) - this terminology sometimes comes up in error messages.
\end_layout

\begin_layout Standard
What happens when an R function is evaluated? The user-provided function
 arguments are evaluated in the calling environment and the results are
 matched to the argument names in the function definition.
 A new environment with its own frame is created, with the frame on the
 call stack.
 Assignment to the argument names is done in the environment, including
 any default arguments.
 The body of the function is evaluated in the environment.
 Any look-up of variables not found in the environment is done using R's
 lexical scoping rules to look in the series of enclosing environments.
 When the function finishes, the return value is passed back to the calling
 frame and the function frame is taken off the stack.
 The environment is removed, unless the environment serves as the enclosing
 environment of another environment.
\end_layout

\begin_layout Standard
I'm not expecting you to fully understand that previous paragraph and all
 the terms in it.
 We'll see all the details in this section.
 
\end_layout

\begin_layout Subsection
Functions as objects
\end_layout

\begin_layout Standard
Everything in R is an object, including functions.
 We can assign functions to variables in the same way we assign numeric
 and other values.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

function-object
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can call a function based on the text name of the function.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

eval-fun
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also pass a function into another function as the actual function
 object.
 This is one aspect of R being a functional programming language.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

fun-as-arg
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also pass in a function based on a a character vector of length one
 with the name of the function.
 Here 
\emph on
match.fun()
\emph default
 is a handy function that extracts a function when the function is passed
 in as an argument of a function.
 It looks in the calling environment for the function and can handle when
 the function is passed in as a function object or as a character vector
 of length 1 giving the function name.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

match-fun
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This allows us to write functions in which the user passes in the function
 (as an example, this works when using 
\emph on
outer()
\emph default
).
 Caution: one may need to think carefully about scoping issues in such contexts.
\end_layout

\begin_layout Standard
Function objects contain three components: an argument list, a body (a parsed
 R statement), and an environment.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

fun-parts
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We'll see more about objects relating to the R language and parsed code
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Computing-on-the"

\end_inset

.
 For now, just realize that the parsed code itself is treated as an object(s)
 with certain types and certain classes.
\end_layout

\begin_layout Subsubsection*

\emph on
do.call()
\end_layout

\begin_layout Standard
The 
\emph on
do.call()
\emph default
 function will apply a function to the elements of a list.
 For example, we can 
\emph on
rbind()
\emph default
 together (if compatible) the elements of a list of vectors instead of having
 to loop over the elements or manually type them in:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

do-call
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why couldn't we just use 
\emph on
rbind()
\emph default
 directly? Basically we're using 
\emph on
do.call()
\emph default
 to use functions that take 
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

 as input (i.e., functions accepting an arbitrary number of arguments) and
 to use the list as the input instead (i.e., to use the list elements).
 
\end_layout

\begin_layout Standard
More generally do.call() is a way to pass arguments to a function where the
 arguments are a list:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

do-call2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Inputs
\end_layout

\begin_layout Standard
Arguments can be specifed in the correct order, or given out of order by
 specifying 
\emph on
name = value
\emph default
.
 R first tries to match arguments by name and then by position.
 In general the more important arguments are specified first.
 You can see the arguments and defaults for a function using 
\emph on
args()
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

args
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can't generally tell directly which arguments are required; in general
 you'd need to look at the documentation.
 R will error out if it is expecting an argument, rather than looking for
 that argument elsewhere.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

args-req2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Functions may have unspecified arguments, which are designated using '...'.
 Unspecified arguments occurring at the beginning of the argument list are
 generally a collection of like objects that will be manipulated (consider
 
\emph on
paste()
\emph default
, 
\emph on
c()
\emph default
, and 
\emph on
rbind()
\emph default
), while unspecified arguments occurring at the end are often optional arguments
 (consider 
\emph on
plot()
\emph default
).
 These optional arguments are sometimes passed along to a function within
 the function.
 For example, here's my own wrapper for plotting, where any additional arguments
 specified by the user will get passed along to plot:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

dots
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Do you see any issues that might arise in using my 
\emph on
pplot()
\emph default
 function - what am I getting at here? Can we fix it?
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
pplot=function(x,y,pch=16,cex=.4,...) plot(x,y,pch=pch,cex=cex,...)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you want to manipulate what the user passed in as the 
\emph on
...

\emph default
 args, rather than just passing them along, you can extract them (the following
 code would be used within a function to which 
\emph on
'...'
\emph default
 is an argument:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

dots-list
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can check if an argument is missing with 
\emph on
missing()
\emph default
.
 Arguments can also have default values, which may be 
\emph on
NULL
\emph default
.
 If you are writing a function and designate the default as 
\emph on
argname = NULL
\emph default
, you can check whether the user provided anything using
\family typewriter
 is.null(argname).

\family default
 The default values can also relate to other arguments.
 As an example, consider 
\emph on
dgamma()
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

dgamma
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we've seen, functions can be passed in as arguments (e.g., see the variants
 of 
\emph on
apply()
\emph default
).
 Note that one does not need to pass in a named function - you can create
 the function on the spot - this is called an 
\emph on
anonymous function
\emph default
 (also called a 
\emph on
lambda function
\emph default
 in some languages such as Python):
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

funs-as-args
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see the arguments using 
\emph on
args()
\emph default
 and extract the arguments using 
\emph on
formals().

\emph default
 
\emph on
formals()
\emph default
 can be helpful if you need to manipulate the arguments.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

formals
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
pairlist 
\emph default
is like a list, but with pairing that in this case pairs argument names
 with default values.
\end_layout

\begin_layout Standard

\emph on
match.call()
\emph default
 will show the user-suppled arguments explicitly matched to named arguments.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

match-call
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Outputs
\end_layout

\begin_layout Standard

\family typewriter
return(x)
\family default
 will specify 
\emph on
x
\emph default
 as the output of the function.
 By default, if 
\emph on
return()
\emph default
 is not specified, the output is the result of the last evaluated statement.
 
\emph on
return()
\emph default
 can occur anywhere in the function, and allows the function to exit as
 soon as it is done.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
invisible(x)
\emph default
 will return 
\emph on
x
\emph default
 and the result can be assigned in the calling environment but it will not
 be printed if not assigned:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

invisible
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A function can only return a single object (unlike Matlab, e.g.), but of course
 we can tack things together as a list and return that, as with 
\emph on
lm()
\emph default
 and many other functions.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

return-list
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Frames and the call stack
\end_layout

\begin_layout Standard
R keeps track of the call stack, which is the series of nested calls to
 functions.
 The stack operates like a stack of cafeteria trays - when a function is
 called, it is added to the stack (pushed) and when it finishes, it is removed
 (popped).
 Each function call is associated with a 
\emph on
frame
\emph default
 that contains the local variables for that function call.
 
\end_layout

\begin_layout Standard
There are a bunch of functions that let us query what frames are on the
 stack and access objects in particular frames of interest.
 This gives us the ability to work with objects in the frame from which
 a function was called.
 
\end_layout

\begin_layout Standard
Some terminology: for our purposes we'll use the terms 
\emph on
frame
\emph default
 and 
\emph on
environment
\emph default
 somewhat interchangeably for the moment.
 A 
\emph on
frame
\emph default
 or 
\emph on
environment
\emph default
 is a collection of named objects.
 (Note that when we talk about variable scope in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Variable-scope"

\end_inset

, we'll have to be more careful with our terminology.) So in the context
 of a function call, the frame is the set of local variables available in
 the function, including arguments passed to the function.
\end_layout

\begin_layout Standard

\emph on
sys.nframe()
\emph default
 returns the number of the current frame/environment and 
\emph on
sys.parent()
\emph default
 the number of the parent, while 
\emph on
parent.frame()
\emph default
 gives the name of the frame/environment of the parent (i.e., the calling)
 frame.
 
\emph on
sys.frame()
\emph default
 gives the name of the frame/environment for a given frame number (for non-negat
ive numbers).
 For negative numbers, it goes back that many frames in the call stack and
 returns the name of the frame/environment.
 I won't print the results here because 
\emph on
knitr
\emph default
 messes up the frame counting somehow.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

frames, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now let's look at some code that gets more information about the call stack
 and the frames involved using 
\emph on
sys.status()
\emph default
, 
\emph on
sys.calls()
\emph default
, 
\emph on
sys.parents()
\emph default
 and 
\emph on
sys.frames()
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

frames2, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Challenge: why did I not do 
\family typewriter
print(sys.status())
\family default
 directly?
\end_layout

\begin_layout Standard
If you're interested in parsing a somewhat complicated example of frames
 in action, Adler provides a user-defined timing function that evaluates
 statements in the calling frame.
\end_layout

\begin_layout Subsection
Approaches to passing arguments to functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Approaches-to-passing"

\end_inset


\end_layout

\begin_layout Subsubsection
Pass by value vs.
 pass by reference
\end_layout

\begin_layout Standard
When talking about programming languages, one often distinguishes 
\emph on
pass-by-value
\emph default
 and 
\emph on
pass-by-reference
\emph default
.
 Pass-by-value means that when a function is called with one or more arguments,
 a copy is made of each argument and the function operates on those copies.
 Pass-by-reference means that the arguments are not copied, but rather that
 information is passed allowing the function to find and modify the original
 value of the objects passed into the function.
 In pass-by-value, changes to an argument made within a function do not
 affect the value of the argument in the calling environment.
 In pass-by-reference changes inside a function do affect the object outside
 of the function.
 R is (roughly) pass-by-value.
 R's designers chose not to allow pass-by-reference because they didn't
 like the idea that a function could have the side effect of changing an
 object.
 However, passing by reference can sometimes be very helpful, and we'll
 see ways of passing by reference later in this Unit (and also note our
 discussion of R6 classes).
\end_layout

\begin_layout Standard
Pass-by-value is elegant and modular in that functions do not have side
 effects - the effect of the function occurs only through the return value
 of the function.
 However, it can be inefficient in terms of the amount of computation and
 of memory used.
 In contrast, pass-by-reference is more efficient, but also more dangerous
 and less modular.
 It's more difficult to reason about code that uses pass-by-reference because
 effects of calling a function can be hidden inside the function.
 
\end_layout

\begin_layout Standard
An important exception is 
\emph on
par()
\emph default
.
 If you change graphics parameters by calling 
\emph on
par()
\emph default
 in a user-defined function, they are changed permanently outside of the
 function.
 One trick is as follows:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

par, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that changing graphics parameters within a specific plotting function
 - e.g., 
\family typewriter
plot(x, y, pch = '+')
\family default
, doesn't change things except for that particular plot.
 Can you think of other R functions that have side effects?
\end_layout

\begin_layout Paragraph*
Pointers
\end_layout

\begin_layout Standard
By way of contrast to a pass-by-value system, I want to briefly discuss
 the idea of a pointer, common in compiled languages such as C.
\end_layout

\begin_layout Standard

\family typewriter
int x = 3;
\end_layout

\begin_layout Standard

\family typewriter
int* ptr;
\end_layout

\begin_layout Standard

\family typewriter
ptr = &x;
\end_layout

\begin_layout Standard

\family typewriter
*ptr * 7; // returns 21
\end_layout

\begin_layout Standard
Here 
\emph on
ptr
\emph default
 is the address of the integer 
\emph on
x
\emph default
.
 
\end_layout

\begin_layout Standard
Vectors in C are really pointers to a block of memory:
\end_layout

\begin_layout Standard

\family typewriter
int x[10];
\end_layout

\begin_layout Standard
In this case 
\emph on
x
\emph default
 will be the address of the first element of the vector.
 We can access the first element as 
\family typewriter
x[0]
\family default
 or 
\family typewriter
*x
\family default
.
\end_layout

\begin_layout Standard
Why have we gone into this? In C, you can pass a pointer as an argument
 to a function.
 The result is that only the scalar address is copied and not the entire
 vector, and inside the function, one can modify the original vector, with
 the new value persisting on exit from the function.
 For example:
\end_layout

\begin_layout Standard

\family typewriter
int myCal(int* ptr){
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

*ptr = *ptr + *ptr;
\end_layout

\begin_layout Standard

\family typewriter
}
\family default

\begin_inset Note Note
status open

\begin_layout Plain Layout
 [draw picture of memory location of y with two pointers to it, one local
 and one global]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When calling C or C++ from R, one (implicitly) passes pointers to the vectors
 into C.
 For example, using the old .C syntax, here's an example:
\end_layout

\begin_layout Standard

\family typewriter
out <- rep(0, n)
\end_layout

\begin_layout Standard

\family typewriter
out <- .C(
\begin_inset Quotes eld
\end_inset

logLik
\begin_inset Quotes erd
\end_inset

, out = as.double(out), 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

theta = as.double(theta))$out
\family default

\begin_inset Newline newline
\end_inset

In C, the function definition looks like this:
\end_layout

\begin_layout Standard

\family typewriter
void logLik(double* out, double* theta)
\end_layout

\begin_layout Paragraph*
Pointers in R?
\end_layout

\begin_layout Standard
Are there pointers in R? From a user perspective, one might say 'no', because
 an R programmer can't use pointers explicitly.
 But pointer-like behavior is occurring behind the scenes in lots of ways:
\end_layout

\begin_layout Itemize
Lists in R are essentially vectors of pointers to the elements of the list
\end_layout

\begin_layout Itemize
Character vectors in R are essentially pointers to the individual character
 strings.
\end_layout

\begin_layout Itemize
R6 objects behave like pointers and are passed by reference rather than
 by copy, as seen in Section 4.4.3.
\end_layout

\begin_layout Itemize
Environments (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:environments"

\end_inset

) behave like pointers and are passed by reference rather than by copy.
\end_layout

\begin_layout Subsubsection
Promises and lazy evaluation
\end_layout

\begin_layout Standard
In actuality, R is not quite pass-by-value; rather it is 
\emph on
call-by-value
\emph default
.
 Copying of arguments is delayed in two ways.
 The first is the idea of promises and lazy evaluation, described here.
 The second is the idea of 
\emph on
copy-on-change
\emph default
, described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Evaluating-memory-use"

\end_inset

.
 Basically, with copy-on-change, copies of arguments are only made if the
 argument is changed within the function.
 Until then the object in the function just refers back to the original
 object.
\end_layout

\begin_layout Standard
Let's see what a 
\emph on
promise
\emph default
 object is.
 In function calls, when R matches user input arguments to formal argument
 names, it does not (usually) evaluate the arguments until they are needed,
 which is called 
\emph on
lazy evaluation
\emph default
.
 Instead the formal arguments are of a special type called a 
\emph on
promise
\emph default
.
 Let's see lazy evaluation in action.
 Do you think the following code will run?
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

lazy-eval, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
What's strange about that? 
\end_layout

\begin_layout Standard
Another example:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

lazy-eval2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lazy evaluation is not just an R thing.
 It also occurs in Spark and in the Python Dask package.
 The basic idea is to delay executation until it's really needed, with the
 goal that if one does so, the system may be able to better optimize a series
 of multiple steps as a joint operation relative to executing them one by
 one.
\end_layout

\begin_layout Paragraph
Where are arguments evaluated?
\end_layout

\begin_layout Standard
User-supplied arguments are evaluated in the calling frame (why?), while
 default arguments are evaluated in the frame of the function (why?):
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

args-eval
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, when 
\emph on
f()
\emph default
 is called, promises for z*5 and 
\family typewriter
x*3
\family default
 are created.
 Then when the code is evaluated, 
\emph on
z
\emph default
 is evaluated in the calling frame and 
\family typewriter
z*5
\family default
 is assigned to 
\emph on
x
\emph default
 in the frame of the function, while 
\family typewriter
x*3
\family default
 is evaluated in the frame of the function and assigned to 
\emph on
y
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
function(x, y = mean(rnorm(1e6)) print(x)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Variable scope
\begin_inset CommandInset label
LatexCommand label
name "subsec:Variable-scope"

\end_inset


\end_layout

\begin_layout Standard
In this section, we seek to understand what happens in the following circumstanc
e.
 Namely, where does R get the value for the object 'x'? 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

scope-example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To consider variable scope, we need to define the terms 
\emph on
environment
\emph default
 and 
\emph on
frame
\emph default
.
 Environments and frames are closely related.
 
\end_layout

\begin_layout Itemize
A 
\emph on
frame
\emph default
 is a collection of named objects.
\end_layout

\begin_layout Itemize
An 
\emph on
environment
\emph default
 is a frame, with a pointer to the 'enclosing environment', i.e., the next
 environment to look for something in.
 (Be careful as this is different than the parent frame of a function.)
\end_layout

\begin_layout Standard
Variables in the enclosing environment (also called the parent environment)
 are available within a function.
 This is the analog of 
\emph on
global variables
\emph default
 in other languages.
 The enclosing environment is the environment in which a function is defined,
 not the environment from which a function is called.
 
\end_layout

\begin_layout Standard
Be careful when using variables from the enclosing environment as the value
 of that variable in the enclosing environment may well not be what you
 expect it to be.
 In general it's bad practice to use variables that are taken from environments
 outside that of a function, but in some cases it can be useful.
 Here are some examples of using variables outside of the frame of a function.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

enclosing, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's dig deeper to understand where R looks for non-local variables.
 
\series bold
R looks for variables that are not local to a function in the 
\emph on
enclosing environment
\emph default
 of the function.
 The 
\emph on
enclosing environment
\emph default
 is the environment in which the function was 
\emph on
defined
\emph default
.

\series default
 Note that the enclosing/parent environment is NOT the environment from
 which the function was called.
 This approach is called 
\emph on
lexical scoping
\emph default
.
\end_layout

\begin_layout Standard
Here are some examples to illustrate scope:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

scope, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here's a somewhat tricky example:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

scope-tricky
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's work through this:
\end_layout

\begin_layout Enumerate
What is the enclosing environment of the function 
\emph on
g()
\emph default
?
\end_layout

\begin_layout Enumerate
What does 
\emph on
g()
\emph default
 use for 
\emph on
y
\emph default
?
\end_layout

\begin_layout Enumerate
When 
\emph on
fun_constructor()
\emph default
 finishes, does its environment disappear? What would happen if it did?
\begin_inset Note Note
status open

\begin_layout Plain Layout
g would not have an enclosing env't!
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
What is the enclosing environment of 
\emph on
myfun()
\emph default
?
\end_layout

\begin_layout Standard
This code helps explain things, but it's a bit confusing because 
\emph on
environment()
\emph default
 gives back different results depending on whether it is given a function
 as its argument.
 If given a function, it returns the enclosing environment for that function.
 If given no argument, it returns the current execution environment.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

scope-envts
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Comprehension problem
\end_layout

\begin_layout Standard
Here's a case where something I tried failed and I had to think more carefully
 about scoping to understand why.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

scope-problem
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Question: what was I hoping that code to do, and why didn't it work? 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[.Random.seed is read into tmp() but rnorm() is getting it from the search
 path for rnorm() which has nothing to do with tmp()]
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Detecting non-local variables
\end_layout

\begin_layout Standard
We can use 
\emph on
codetools::findGlobals
\emph default
 to detect non-local variables when we are programming.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

findGlobals
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Is that result what you would expect? What does it say about my statement
 that using non-local variables is a bad idea?
\end_layout

\begin_layout Paragraph*
Closures
\end_layout

\begin_layout Standard
One way to avoid passing data by value is to associate data with a function,
 using a 
\emph on
closure
\emph default
.
 This is a functional programming way to achieve something like an OOP class.
 This 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia entry"
target "https://en.wikipedia.org/wiki/Closure_(computer_programming)"
literal "false"

\end_inset

 nicely summarizes the idea, which is not an R-specific construct.
 This involves creating one (or more functions) within a function call and
 returning the function(s) as the output.
 When one executes the original function, the new function(s) is created
 and returned and one can then call that new function(s).
 The new function then can access objects in the enclosing environment (the
 environment of the original function) and can use `<<-` to assign into
 the enclosing environment, to which the function (or the multiple functions)
 have access.
 The nice thing about this compared to using a global variable is that the
 data in the closure is bound up with the function(s) and is protected from
 being changed by the user of the closure.
 Chambers provides an example of this in Sec.
 5.4.
\begin_inset Newline newline
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
[[[perhaps see http://www.r-bloggers.com/function-closures-and-s4-methods/?utm_sou
rce=feedburner&utm_medium=email&utm_campaign=Feed%3A+RBloggers+%28R+bloggers%29
 for S4 and closures ]]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

closures
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here's a fun example.
 You might do this with an 
\emph on
apply()
\emph default
 variant, in particular 
\emph on
replicate()
\emph default
, but this is slick:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

closure-boot
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Environments and the search path
\end_layout

\begin_layout Standard
So far we've seen lexical scoping in action primarily in terms of finding
 variables in a single enclosing environment.
 But what if the variable is not found in either the frame/environment of
 the function or the enclosing environment? When R goes looking for an object
 (in the form of a symbol), it starts in the current environment (e.g., the
 frame/environment of a function) and then runs up through the enclosing
 environments, until it reaches the global environment, which is where R
 starts when you open R (it actually continues further up; see below).
 In general, as we've seen, these environments are not the environments
 of the calling function(s) - i.e., they are 
\emph on
not
\emph default
 the frames on the stack (see the next Section).
 
\end_layout

\begin_layout Standard
By default objects are created in the global environment, 
\emph on
.GlobalEnv
\emph default
.
 As we've seen, the environment within a function call has as its enclosing
 environment the environment where the function was defined (not the environment
 from which it was called), and based on lexical scoping this is next place
 that is searched if an object can't be found in the frame of the function
 call.
 As an example, if an object couldn't be found within the environment of
 an 
\emph on
lm()
\emph default
 function call, R would first look in the environment (i.e., the 
\emph on
namespace
\emph default
) of the stats package (since this is the environment where 
\emph on
lm()
\emph default
 is defined and is therefore the enclosing environment for 
\emph on
lm()
\emph default
), then in packages imported by the stats package, then the base package,
 and then the global environment.
\end_layout

\begin_layout Standard
If R can't find the object when reaching the global environment, it runs
 through the search path, which you can see with 
\emph on
search()
\emph default
.
 The search path is a set of additional environments.
 Generally packages are created with namespaces, i.e., each has its own environmen
t, as we see based on 
\emph on
search()
\emph default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Data frames or list that you attach using 
\emph on
attach()
\emph default
 generally are placed just after the global environment.
 [BAD practice so don't mention, but do try to remember when it is ok to
 use attach - Martin Maechler's 2014 useR talk?]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

search
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also see the nestedness of environments using the following code,
 using 
\emph on
environmentName()
\emph default
, which prints out a nice-looking version of the environment name.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

nested-env
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that eventually the global environment and the environments of the
 packages are nested within the base environment (of the base package) and
 the empty environment.
 Note that here 
\emph on
parent
\emph default
 
\series bold
is
\series default
 referring to the enclosing environment, even though it is best to talk
 about 
\emph on
enclosing environment
\emph default
 rather than parent environment.
\end_layout

\begin_layout Standard
We can retrieve and assign objects in a particular environment and/or namespace
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that our (bogus) 
\emph on
lm()
\emph default
 function masks but does not overwrite the default function.
 If we remove ours, then the default one is still there.
\end_layout

\begin_layout Subsection
Alternatives to pass by value in R
\end_layout

\begin_layout Standard
There are occasions we do not want to pass by value.
 In addition to avoiding copies and the attendant computation and memory
 use, another reason is when we want a function to modify a complicated
 object without having to return it and re-assign it in the parent environment.
 There are several work-arounds:
\end_layout

\begin_layout Enumerate
We can use R6 (or Reference Class) objects.
 
\end_layout

\begin_layout Enumerate
We can use a 
\emph on
closure
\emph default
, as discussed previously.
\end_layout

\begin_layout Enumerate
We can access the object in the enclosing environment as a 'global variable',
 as we've seen when discussing scoping.
 More generally we can access the object using 
\emph on
get()
\emph default
, specifying the environment from which we want to obtain the variable.
 To specify the location of an object when using 
\emph on
get()
\emph default
, we can generally specify (1) a position in the search path, (2) an explicit
 environment, or (3) a location in the call stack by using 
\emph on
sys.frame()
\emph default
.
 However we cannot change the value of the object in the parent environment
 without some additional tools:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
We can use the '<<-' operator to assign into an object in the parent environment
 (provided an object of that name exists in the parent environment).
 
\end_layout

\begin_layout Enumerate
We can also use 
\emph on
assign()
\emph default
, specifying the environment in which we want the assignment to occur.
\end_layout

\begin_layout Standard
While these techniques are possible and ok for exploratory coding, they're
 bad practice for more formal code development.
\end_layout

\end_deeper
\begin_layout Enumerate
We can use replacement functions (Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Unexpected-functions-and"

\end_inset

), which hide the reassignment in the parent environment from the user.
 Note that a second copy is generally created in this case, but the original
 copy is quickly removed.
\end_layout

\begin_layout Itemize
A related approach is to wrap data with a function using 
\emph on
with()
\emph default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This approach appeared in Problem Set 2.
 (Fall2012)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

with
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Question
\series default
: When would it be useful to have an object carried along with a function
 as done here?
\end_layout

\begin_layout Subsection
Creating and working in an environment (optional)
\begin_inset CommandInset label
LatexCommand label
name "subsec:environments"

\end_inset


\end_layout

\begin_layout Standard
We've already talked extensively about the environments that R creates.
 Occasionally you may want to create your own environment in which to store
 objects.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

new.env
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before the existence of R6 and Reference Classes, using an environment was
 one way to pass objects by reference, avoiding having to re-assign the
 output (and in fact R6 classes are just a wrapper around the use of environment
s).
 Here's an example where we iteratively update a random walk (but note that
 if I were actually doing this I would use an R6 class and not an environment).
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

envt-container
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can use 
\emph on
eval()
\emph default
 to evaluate some code within a specified environment.
 By default, it evaluates in the result of 
\emph on
parent.frame()
\emph default
, which amounts to evaluating in the frame from which 
\emph on
eval()
\emph default
 was called.
 
\emph on
evalq()
\emph default
 avoids having to use 
\emph on
quote()
\emph default
.
 Here we override the default and evaluate in the 
\emph on
myWalk
\emph default
 environment we created:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

eval-in-env
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operators
\end_layout

\begin_layout Standard
Operators, such as '
\family typewriter
\emph on
+
\family default
\emph default
', '
\emph on
[
\emph default
' are just functions, but their arguments can occur both before and after
 the function call:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

operators, tidy=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In general, you can use back-ticks to refer to the operators as operators
 instead of characters.
 In some cases single or double quotes also work.
 We can look at the code of an operator as follows using back-ticks to escape
 out of the standard R parsing, e.g., 
\family typewriter
`%*%`.
\end_layout

\begin_layout Standard
Finally, since an operator is just a function, you can use it as an argument
 in various places:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

pass-operator
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can define your own 
\emph on
binary
\emph default
 operator (an operator taking two arguments) using a string inside 
\emph on
%
\emph default
 symbols.
 Here's how we could do Python-style string addition:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

define-operator
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since operators are just functions, there are cases in which there are optional
 arguments that we might not expect.
 Here's how to pass a sometimes useful argument to the bracket operator
 (in this case avoiding conversion from a matrix to a vector, which can
 mess up subsequent code).
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

operator-args
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also use operators with our S3 classes.
 Picking up our example from our discussion of S3 OOP, the following example
 will be a bit silly (it would make more sense with a class that is a mathematic
al object) but indicates the power of having methods.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

class-operators
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Unexpected functions and replacement functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Unexpected-functions-and"

\end_inset


\end_layout

\begin_layout Standard
All code in R can be viewed as a function call.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The subset assignment operator is '[<-'.
 
\end_layout

\begin_layout Plain Layout
> animals <- c("cow", "chicken", "pig", "tuba")
\end_layout

\begin_layout Plain Layout
> '[<-'(animals, 4, 
\begin_inset Quotes eld
\end_inset

duck
\begin_inset Quotes erd
\end_inset

)
\begin_inset Newline newline
\end_inset

So animals[4] <- 
\begin_inset Quotes eld
\end_inset

duck
\begin_inset Quotes erd
\end_inset

 is actually parsed by R to run the code above.
 We'll talk about expression parsing a bit later.
 Note that the parser has to be clever enough to realize that the animals
 argument comes before the operator syntax and the '4' argument is in the
 middle of it.
 
\end_layout

\begin_layout Plain Layout
Challenge: How could you write R code that itself parses an R statement
 such as animals[4] <- 
\begin_inset Quotes eld
\end_inset

duck
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What do you think is the functional version of the following code? What
 are the arguments?
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

all-is-fun, eval = FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Assignments that involve functions or operators on the left-hand side (LHS)
 are called 
\emph on
replacement expressions
\emph default
 or 
\emph on
replacement functions.
 
\emph default
These can be quite handy.
 Here are a few examples:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

replace-funs, eval = FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Replacement expressions are actually function calls.
 The R interpreter calls the replacement function (which often creates a
 new object that includes the replacement) and then assigns the result to
 the name of the original object.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

replace-funs2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The old version of 
\emph on
mat
\emph default
 still exists until R's memory management cleans it up, but it's no longer
 referred to by the symbol '
\emph on
mat
\emph default
'.
 Occasionally this sort of thing might cause memory usage to increase (for
 example it's possible if you're doing replacements on large objects within
 a loop), but in general things should be fine.
\end_layout

\begin_layout Standard
You can define your own replacement functions like this, with the requirements
 that the last argument be named '
\emph on
value
\emph default
' and that the function return the entire object:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

create-replace
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can use replacement functions with S3 classes we define.
 Again, picking up our example from our discussion of S3 OOP, this is again
 a bit silly but we could do the following.
 We need to define the generic replacement function and then the class-specific
 one.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

replacement
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Summing up
\end_layout

\begin_layout Standard
Now that we've seen all that, this summary that I included at the start
 of Section 6 should make sense.
\end_layout

\begin_layout Standard
What happens when an R function is evaluated? The user-provided function
 arguments are evaluated in the calling environment and the results are
 matched to the argument names in the function definition.
 A new environment with its own frame is created, with the frame on the
 call stack.
 Assignment to the argument names is done in the environment, including
 any default arguments (as promises if the input arguments are variables
 or code).
 The body of the function is evaluated in the environment.
 Any look-up of variables not found in the environment is done using R's
 lexical scoping rules to look in the series of enclosing environments.
 When the function finishes, the return value is passed back to the calling
 frame and the function frame is taken off the stack.
 The environment is removed, unless the environment serves as the enclosing
 environment of another environment.
\end_layout

\begin_layout Section
Efficiency
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
2021: not sure what this refers to but perhaps to where I note areas for
 improved efficiency: some code that could be more efficient - don't need
 full pertub alloc; inverse, order of ops
\end_layout

\end_inset

In part because R is an interpreted language and in part because R is very
 dynamic (objects can be modified essentially arbitrarily after being created),
 R can be slow.
 Hadley Wickham's Advanced R book has a section on Performance that discusses
 this in detail.
 However, there are a variety of ways that one can write efficient R code.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
why is R slow for a fxn in particular: symbol lookup, AST created, promises
 created, arguments checked, env't created
\end_layout

\begin_layout Plain Layout
could give example of if() in for loop changing the object type
\end_layout

\begin_layout Plain Layout
out <- rep(NA, 20)
\end_layout

\begin_layout Plain Layout
for(i in 1:20) {
\end_layout

\begin_layout Plain Layout
a <- runif(1)
\end_layout

\begin_layout Plain Layout
if(a < 0.5) tmp <- 7 else tmp <- 'abc'
\end_layout

\begin_layout Plain Layout
if(a < 0.01) rm(tmp)
\end_layout

\begin_layout Plain Layout
out[i] <- tmp * 3
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In general, make use of R's built-in functions, as these tend to be implemented
 internally (i.e., via compiled code in C or Fortran).
 In particular, if R is linked to optimized BLAS and Lapack code (e.g.
 Intel's 
\emph on
MKL
\emph default
, 
\emph on
OpenBLAS
\emph default
 [on BCE and the SCF Linux servers], AMD's 
\emph on
ACML
\emph default
 [on the SCF Linux cluster, 
\emph on
vecLib
\emph default
 for Macs [on the SCF Macs]), you should have good performance (potentially
 comparable to Matlab and to coding in C).
 Sometimes you can figure out a trick to take your problem and transform
 it to make use of the built-in functions.
\end_layout

\begin_layout Standard
Note that I run a lot of iterative algorithms so I pay attention to making
 sure my calculations are fast as they are done repeatedly.
 Similarly, one would want to pay attention to speed when doing large simulation
s and bootstrapping, and in some cases for optimization.
 And if you're distributing code, it's good to have it be efficient.
 But in other contexts, it may not be worth your time.
 Also, it's good practice to code it transparently first to reduce bugs
 and then to use tricks to speed it up and make sure the fast version works
 correctly.
 
\end_layout

\begin_layout Standard
Results can vary with with your system setup and version of R, so the best
 thing to do is figure out where the bottlenecks are in your code (e.g., with
 
\emph on
Rprof()
\emph default
 or just some basic use of 
\emph on
system.time()
\emph default
 and 
\emph on
(micro)benchmark()
\emph default
), and then play around with alternative specifications.
 And as you gain more experience, you'll get some intuition for what approaches
 might improve speed, but even with experience I find myself often surprised
 by what matters and what doesn't.
 It's often worth trying out a bunch of different ideas; 
\emph on
system.time(), microbenchmark()
\emph default
 (or 
\emph on
benchmark()
\emph default
) are your workhorse tools in this context.
\end_layout

\begin_layout Subsection
Writing efficient code 
\end_layout

\begin_layout Standard
For material on efficient R coding, including tools for timing and profiling
 your code to understand where the bottlenecks are, see the tutorial, 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "Writing efficient R code"
target "https://github.com/berkeley-scf/tutorial-efficient-R"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsection
A note on hashing
\end_layout

\begin_layout Standard
In the tutorial on efficient R coding, I mention that looking up objects
 by name in an R environment occurs via hashing, so it can be very fast.
 I'll briefly describe what hashing is here.
\end_layout

\begin_layout Standard
A hash function is a function that takes as input some data and maps it
 to a fixed-length output that can be used as a shortened reference to the
 data.
 We've seen this in the context of git commits where each commit was labeled
 with a long base-16 number.
 This also comes up when verifying files on the Internet.
 You can compute the hash value on the file you get and check that it is
 the same as the hash value associated with the legitimate copy of the file.
\end_layout

\begin_layout Standard
For our purposes here, hashing can allow one to look up values by their
 name via a hash table.
 The idea is that you have a set of key-value pairs (sometimes called a
 dictionary) where the key is the name associated with the value and the
 value is some arbitrary object.
 Hashing allows one to quickly determine an index associated with the key
 and therefore quickly find the relevant value based on the index.
 For example, one approach is to compute the hash as a function of the key
 and then take the remainder when dividing by the number of key-value pairs
 to get the index.
 Here's the procedure in pseudocode:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

hash = hashfunc(key) 
\end_layout

\begin_layout Plain Layout

index = hash %% array_size 
\end_layout

\begin_layout Plain Layout

## %% is modulo operator - it gives the remainder
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In general, there will be collisions, with multiple keys assigned to the
 same index, but usually there will be a small number of keys associated
 with a given index or slot, and determining the correct value within a
 given index/slot (also called a bucket) is fast.
 Put another way, the hash function distributes the keys amongst an array
 of buckets and allows one to look up the appropriate bucket quickly based
 on the computed index value.
 When the hash table is properly set up, the cost of looking up a value
 does not depend on the number of key-value pairs stored.
\end_layout

\begin_layout Subsection
Other approaches to speeding up R (optional)
\end_layout

\begin_layout Subsubsection
pqR and other R engines
\end_layout

\begin_layout Standard
Radford Neal, a prominent statistician/computer scientist has been working
 on a project called 
\emph on
pqR
\emph default
 (pretty quick R) to rewrite some aspects of R to make them faster.
 There are also a few other projects that aim to reimplement the 
\begin_inset Quotes eld
\end_inset

R engine
\begin_inset Quotes erd
\end_inset

 such that one could run one's R code with different back ends.
\end_layout

\begin_layout Standard
Here are some of the highlights of 
\emph on
pqR
\emph default
 (from a couple years ago) in terms of efficiency, as discussed at 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://radfordneal.github.io/pqR/"
literal "false"

\end_inset

:
\end_layout

\begin_layout Enumerate
When R runs code such as just below, it actually creates a vector 1,2,....,n,
 (which can be computationally and memory intensive for large n) and then
 iterates over the values in the vector.
 pqR avoids this vector creation.
 As discussed and illustrated in Section 8, 
\series bold
this improvement is incorporated into R 3.5.0 and later versions
\series default
.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
for(i in 1:n) { }
\begin_inset Newline newline
\end_inset

vec[1:n]
\end_layout

\end_deeper
\begin_layout Enumerate
pqR automatically uses multiple cores for some calculations.
\end_layout

\begin_layout Enumerate
pqR avoid some checks for NA and NaN and the like in matrix calculations
 in which such checking would be slow and it doesn't make sense to check
 for them anyway.
\end_layout

\begin_layout Subsubsection
Byte compiling
\end_layout

\begin_layout Standard
R now allows you to compile R code, which goes by the name of byte compiling.
 Byte-compiled code is a special representation that can be executed more
 efficiently because it is in the form of compact codes that encode the
 results of parsing and semantic analysis of scoping and other complexities
 of the R source code.
 This byte code can be executed faster than the original R code because
 it skips the stage of having to be interpreted by the R interpreter.
\end_layout

\begin_layout Standard
The functions in the 
\emph on
base
\emph default
 and 
\emph on
stats
\emph default
 packages are now byte-compiled by default.
 (If you print out a function that is byte-compiled, you'll see something
 like 
\emph on
<bytecode: 0x243a368>
\emph default
 at the bottom.
\end_layout

\begin_layout Standard
We can byte compile our own functions using 
\emph on
cmpfun()
\emph default
.
 Here's an example (silly since as experienced R programmers, we would use
 vectorized calculation here rather than this unvectorized code.)
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

byte, cache=TRUE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can compile an entire source file with 
\emph on
cmpfile()
\emph default
, which produces a 
\emph on
.Rc
\emph default
 file.
 You then need to use 
\emph on
loadcmp()
\emph default
 to load in the 
\emph on
.Rc
\emph default
 file, which runs the code.
\end_layout

\begin_layout Standard
Unfortunately, in my experience, byte compiling doesn't usually speed things
 up much.
 
\end_layout

\begin_layout Subsection
Challenges
\end_layout

\begin_layout Standard
We'll work on some of these challenges in class.
 In addition, one or more of these challenges will appear on PS4.
\end_layout

\begin_layout Standard

\series bold
Challenge 1
\series default
: Here's a calculation of the sort needed in mixture component modeling.
 I have a vector of 
\begin_inset Formula $n$
\end_inset

 observations.
 I need to find the likelihood of each observation under each of 
\begin_inset Formula $p$
\end_inset

 mixture components (i.e., what's the likelihood if it came from each of the
 components).
 (In this case, the the likelihood is simply the normal density of the observati
on given the mean and standard deviation of the component normal distribution.)
 So I should produce a matrix of 
\begin_inset Formula $n$
\end_inset

 rows and 
\begin_inset Formula $p$
\end_inset

 columns where the value in the 
\begin_inset Formula $i$
\end_inset

th row, 
\begin_inset Formula $j$
\end_inset

th column is the likelihood of the 
\begin_inset Formula $i$
\end_inset

th observation under the 
\begin_inset Formula $j$
\end_inset

th mixture component.
 The idea is that the likelihoods for a given observation are used in assigning
 observations to clusters.
 A naive implementation is:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

mixture-example, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\emph on
dnorm()
\emph default
 can handle matrices and vectors as the observations 
\series bold
and
\series default
 as the means and sds, so there are multiple ways to do this.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[mixtureExample.q]
\end_layout

\end_inset

 Try to figure out the fastest way to do this, amongst the options of looping
 over the mixture components, looping over the observations, using vectorized
 operations that recycle the observations, using vectorized operations that
 recycle the mixture components, etc.
 
\end_layout

\begin_layout Standard

\series bold
Challenge 2
\series default
: Here's a calculation of the sort needed in a mixed membership model, where
 each observation is associated with some number of components.
 Suppose you have 
\begin_inset Formula 
\[
y_{i}\sim\mathcal{N}(\sum_{j=1}^{m_{i}}w_{i,j}\mu_{ID[i,j]},\sigma^{2})
\]

\end_inset

for a large number of observations, 
\begin_inset Formula $n$
\end_inset

.
 I give you a vector of 
\begin_inset Formula $\mu=(\mu_{1},\ldots,\mu_{K})$
\end_inset

 values and a ragged list of weights (i.e., the number of weights varies by
 observation) and a ragged list of IDs identifying the cluster corresponding
 to each weight (note 
\begin_inset Formula $m_{i}$
\end_inset

 varies by observation).
 Figure out how to calculate the vector of means, 
\begin_inset Formula $\sum_{j}w_{i,j}\mu_{ID[i,j]}$
\end_inset

 as fast as possible.
 Suppose that 
\begin_inset Formula $m_{i}$
\end_inset

 never gets too big (but 
\begin_inset Formula $\mu$
\end_inset

 might have many elements) - could this help you? Part of thinking this
 through involves thinking about how you want to store the information so
 that the calculations can be done quickly.
 The data file 
\emph on
mixedMember.Rda
\emph default
 contains example data for two scenarios: Scenario A has many 
\begin_inset Formula $\mu$
\end_inset

 values and Scenario B has few 
\begin_inset Formula $\mu$
\end_inset

 values.
\end_layout

\begin_layout Standard

\series bold
Challenge 3
\series default
: Write code that simulates a random walk in two dimensions for 
\begin_inset Formula $n$
\end_inset

 steps.
 First write out a straightforward implementation that involves looping.
 Then try to speed it up.
 The 
\emph on
cumsum()
\emph default
 function may be helpful.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Extra: simulate an excited random walk.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Challenge 4:
\series default
 Determine if it's faster to subset based on vector of indices or a vector
 of logicals.
 Determine if it matters how big the original object is and how large the
 subset is, as well as whether the vector of indices is ordered.
\end_layout

\begin_layout Standard

\series bold
Challenge 5:
\series default
 Figure out how to improve the efficiency of the following code chunk, which
 is part of an iterative optimization of a log-likelihood for a student's
 PhD research.
 Some test data is in 
\emph on
likLoops.Rda
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

challenge5, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Challenge 6
\series default
: Another problem involving a computation from a student's PhD research.
 The following is the probability mass function for an overdispersed binomial
 random variable:
\begin_inset Formula 
\begin{eqnarray*}
P(Y & = & y)=\frac{f(y;n,p,\phi)}{\sum_{k=0}^{n}f(k;n,p,\phi)}\\
f(k;n,p,\phi) & = & {n \choose k}\frac{k^{k}(n-k)^{n-k}}{n^{n}}\left(\frac{n^{n}}{k^{k}(n-k)^{n-k}}\right)^{\phi}p^{k\phi}(1-p)^{(n-k)\phi},
\end{eqnarray*}

\end_inset

where the denominator serves as a normalizing constant to ensure this is
 a valid probability mass function.
 How would one efficiently code the computation of the denominator? For
 our purposes here you can take 
\begin_inset Formula $n=2000$
\end_inset

, 
\begin_inset Formula $p=0.3$
\end_inset

 and 
\begin_inset Formula $\phi=0.5$
\end_inset

 when you need to actually run your code.
\end_layout

\begin_layout Standard

\series bold
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
Challenge 7
\series default
: Yet another problem from a student's PhD research.
 This is a very simplified version of a bioinformatics problem.
 
\end_layout

\begin_layout Plain Layout
Fact 1: DNA sequencing involves chopping up the long sequence of DNA on
 a chromosome into many short 
\emph on
reads
\emph default
, which may overlap and are of various lengths.
 
\end_layout

\begin_layout Plain Layout
Fact 2: DNA is composed of interspersed chunks of DNA that code for proteins
 (exons) and chunks that do not code for proteins (introns).
 The introns are stripped out during creation of the protein.
 
\end_layout

\begin_layout Plain Layout
As part of a workflow, the student needed to determine, for a large number
 of exons, how many reads each exon overlapped with.
 The file 
\emph on
exons.Rda
\emph default
 has position information for the reads (in an object called 
\emph on
reads
\emph default
) as well as position information for a number of exons (in 
\emph on
exons
\emph default
).
 Each element of 
\emph on
reads
\emph default
, which is a list, is a set of short sequences making up a single read.
 So the challenge is to figure out, for each exon, how many of the reads
 there are for which the exon overlaps at least one of the short sequences
 making up the read.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Challenge 7
\series default
: And yet another problem from a student's PhD research (this one from a
 discussion just a few weeks ago).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note for next time: sample() in R does clever thing - uses runif()*n to
 select one from 1:n, then moves last element of 1:n into position that
 was selected,then selectinos one from 1:(n-1) and so on; Note that sample
 is much faster than anything I can come up with in R
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The goal is to write a very fast function for selecting a random sample
 of size k from a population of size n.
 
\end_layout

\begin_layout Standard
There are two algorithms: 
\end_layout

\begin_layout Enumerate
PIKK algorithm: Generate n random numbers and choose the elements of the
 population corresponding to the k smallest numbers.
 
\end_layout

\begin_layout Enumerate
Fisher-Yates-Knuth-Durstenfeld shuffle algorithm: This involves considering
 each element in turn and swapping it with a random element later in the
 set.
 Then return the first k.
 
\end_layout

\begin_layout Standard
Here are implementations of the two algorithms.
 Can we speed up either of them without resorting to coding in a faster
 language or directly using 
\emph on
sample()
\emph default
 (which calls out to a fast C function)?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<challenge7, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Challenge 8: 
\series default
Suppose we have a matrix in which each row is a vector of probabilities
 that add to one, and we want to generate a categorical sample based on
 each row.
 E.g., the first row might be (0.9, 0.05, 0.05) and the second row might be (0.1,
 0.85, .0.5).
 When we generate the first sample, it is very likely to be a 1 and the
 second sample is very likely to be a 2.
 We could do this using a for loop over the rows of the matrix, and the
 
\emph on
sample()
\emph default
 function, but that is a lot slower than some other ways we might do it.
 How can we do it faster?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<challenge8, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Evaluating memory use
\begin_inset CommandInset label
LatexCommand label
name "sec:Evaluating-memory-use"

\end_inset


\end_layout

\begin_layout Standard
The main things to remember when thinking about memory use are: (1) numeric
 vectors take 8 bytes per element and (2) we need to keep track of when
 large objects are created, including local variables in the frames of functions.
\end_layout

\begin_layout Standard
In some of our work here we'll use functions from the 
\emph on
pryr
\emph default
 package, which provides functions to help understand what is going on under
 the hood in R.
\end_layout

\begin_layout Standard

\series bold
In general, don't try to run this code within RStudio, as some of how RStudio
 works affects memory use.
 Also, some of the output in this PDF is missing or incorrect relative to
 running the code directly within R, because of effects from the knitting
 process.
 
\end_layout

\begin_layout Subsection
Allocating and freeing memory
\end_layout

\begin_layout Standard
Unlike compiled languages like C, in R we do not need to explicitly allocate
 storage for objects.
 However, we have seen that there are times that we do want to allocate
 storage in advance, rather than successively concatenating onto a larger
 object.
 
\end_layout

\begin_layout Standard
R automatically manages memory, releasing memory back to the operating system
 when it's not needed via garbage collection.
 Very occasionally you may want to remove large objects as soon as they
 are not needed.
 
\emph on
rm()
\emph default
 does not actually free up memory, it just disassociates the name from the
 memory used to store the object.
 In general R will quickly clean up such objects without a reference (i.e.,
 a name), but it's possible that very occasionally you might need to call
 
\emph on
gc()
\emph default
 to force the garbage collection.
 This uses some computation so it's generally not recommended.
\end_layout

\begin_layout Standard
In a language like C in which the user allocates and frees up memory, memory
 leaks are a major cause of bugs.
 Basically if you are looping and you allocate memory at each iteration
 and forget to free it, the memory use builds up inexorably and eventually
 the machine runs out of memory.
 In R, with automatic garbage collection, this is generally not an issue,
 but occasionally memory leaks do occur.
 
\end_layout

\begin_layout Subsection
Monitoring overall memory use
\end_layout

\begin_layout Subsubsection
Monitoring use within R
\end_layout

\begin_layout Standard
There are a number of ways to see how much memory is being used.
 When R is actively executing statements, you can use 
\emph on
top
\emph default
 from the UNIX shell.
 In R, 
\emph on
gc()
\emph default
 reports memory use and free memory as 
\emph on
Ncells
\emph default
 and 
\emph on
Vcells
\emph default
.
 
\emph on
Ncells
\emph default
 concerns the overhead of running R and 
\emph on
Vcells
\emph default
 relates to objects created by the user, so you'll want to focus on 
\emph on
Vcells
\emph default
.
 You can see the number of Mb currently used (the 
\begin_inset Quotes eld
\end_inset


\emph on
used
\emph default

\begin_inset Quotes erd
\end_inset

 column of the output) and the maximum used in the session (the 
\begin_inset Quotes eld
\end_inset


\emph on
max used
\emph default

\begin_inset Quotes erd
\end_inset

 column)
\begin_inset Quotes erd
\end_inset

.
 A newer alternative is to use functions in the 
\emph on
pryr
\emph default
 package such as 
\emph on
mem_used()
\emph default
 and 
\emph on
mem_change()
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

gc
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can reset the value given for max used, with 
\family typewriter
gc(reset = TRUE)
\family default
.
\end_layout

\begin_layout Standard
In Windows only, 
\emph on
memory.size()
\emph default
 tells how much memory is being used.
 
\end_layout

\begin_layout Standard
You can check the amount of memory used by individual objects with 
\emph on
object.size()
\emph default
.
\end_layout

\begin_layout Standard
Here is a useful function, 
\emph on
ls.sizes()
\emph default
, that wraps 
\emph on
object.size()
\emph default
 to report the largest 
\begin_inset Formula $n$
\end_inset

 objects in a given environment:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

ls-sizes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unfortunately with R6 and ReferenceClasses, closures, environments, and
 other such 
\begin_inset Quotes eld
\end_inset

containers
\begin_inset Quotes erd
\end_inset

, it can be hard to see how much memory the object is using, including all
 the components of the object.
 Here's a trick where we serialize the object, as if to export it, and then
 see how long the binary representation is.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

serialize
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[not needed for Fall2012 as it was a PS2 problem]
\end_layout

\end_inset

One frustration with memory management is that if your code bumps up against
 the memory limits of the machine, it can be very slow to respond even when
 you're trying to cancel the statement with 
\emph on
Ctrl-C
\emph default
.
 You can impose memory limits in Linux by starting R (from the UNIX prompt)
 in a fashion such as this
\end_layout

\begin_layout Standard

\family typewriter
> R --max-vsize=1000M
\family default

\begin_inset Newline newline
\end_inset

Then if you try to create an object that will push you over that limit or
 execute code that involves going over the limit, it will simply fail with
 the message 
\begin_inset Quotes eld
\end_inset


\emph on
Error: vector memory exhausted (limit reached?)
\emph default

\begin_inset Quotes erd
\end_inset

.
 So this approach may be a nice way to avoid paging/swapping by setting
 the maximum in relation to the physical memory of the machine.
 It might also help in debugging memory leaks because the program would
 fail at the point that memory use was increasing.
 I haven't played around with this much, so offer this with a note of caution.
\end_layout

\begin_layout Standard
Apparently there is a memory profiler in R, 
\emph on
Rprofmem
\emph default
, but it needs to be enabled when R is compiled (i.e., installed on the machine),
 because it slows R down even when not used.
 So I've never gotten to the point of playing around with it.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
.Internal(inspect(x[1])) is presumably creating a 1-vec temporraily which
 is why it is not the same address as x itself
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Monitoring overall memory use on a UNIX-style computer
\end_layout

\begin_layout Standard
To understand how much memory is available on your computer, one needs to
 have a clear understanding of disk caching.
 The operating system will generally cache files/data in memory when it
 reads from disk.
 Then if that information is still in memory the next time it is needed,
 it will be much faster to access it the second time around than if it had
 to read the information from disk.
 While the cached information is using memory, that same memory is immediately
 available to other processes, so the memory is available even though it
 is 
\begin_inset Quotes eld
\end_inset

in use
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
We can see this via 
\family typewriter
free -h
\family default
 (the 
\begin_inset Quotes eld
\end_inset

-h
\begin_inset Quotes erd
\end_inset

 is for 'human-readable', i.e.
 show in GB (G)) on Linux machine.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

      total used free shared buff/cache available 
\end_layout

\begin_layout Plain Layout

Mem:   251G 998M 221G   2.6G        29G      247G 
\end_layout

\begin_layout Plain Layout

Swap:  7.6G 210M 7.4G
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You'll generally be interested in the 
\emph on
Memory
\emph default
 row.
 (See below for some comments on 
\emph on
Swap
\emph default
.) The 
\emph on
shared
\emph default
 column is complicated and probably won't be of use to you.
 The 
\emph on
buff/cache
\emph default
 column shows how much space is used for disk caching and related purposes
 but is actually available.
 Hence the 
\emph on
available
\emph default
 column is the sum of the 
\emph on
free
\emph default
 and 
\emph on
buff/cache
\emph default
 columns (more or less).
 In this case only about 1 GB is in use (indicated in the 
\emph on
used
\emph default
 column).
 
\end_layout

\begin_layout Standard

\emph on
top
\emph default
 (Linux or Mac) and
\emph on
 vmstat
\emph default
 (on Linux) both show overall memory use, but remember that the amount actually
 available to you is the amount free plus any buffer/cache usage.
 Here is some example output from 
\emph on
vmstat
\emph default
: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 
\end_layout

\begin_layout Plain Layout

r b   swpd      free   buff    cache si so bi bo in cs us sy id wa st 
\end_layout

\begin_layout Plain Layout

1 0 215140 231655120 677944 30660296  0  0  1  2  0  0 18  0 82  0  0
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It shows 232 GB free and 31 GB used for cache and therefore available, for
 a total of 263 GB available.
\end_layout

\begin_layout Standard
Here are some example lines from 
\emph on
top
\emph default
: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

KiB Mem : 26413715+total, 23180236+free, 999704 used, 31335072 buff/cache
 
\end_layout

\begin_layout Plain Layout

KiB Swap:  7999484 total,  7784336 free, 215148 used.
 25953483+avail Mem
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see that this machine has 264 GB RAM (the total column in the 
\emph on
Mem
\emph default
 row), with 259.5 GB available (232 GB free plus 31 GB buff/cache as seen
 in the 
\emph on
Mem
\emph default
 row).
 (I realize the numbers don't quite add up for reasons I don't fully understand,
 but we probably don't need to worry about that degree of exactness.) Only
 1 GB is in use.
 
\end_layout

\begin_layout Standard

\emph on
Swap
\emph default
 is essentially the reverse of disk caching.
 It is disk space that is used for memory when the machine runs out of physical
 memory.
 You never want your machine to be using swap for memory because your jobs
 will slow to a crawl.
 As seen above, the 
\emph on
swap
\emph default
 line in both 
\emph on
free
\emph default
 and 
\emph on
top
\emph default
 shows 8 GB swap space, with very little in use, as desired.
 
\end_layout

\begin_layout Subsection
The heap and the stack
\end_layout

\begin_layout Standard
The 
\emph on
heap
\emph default
 is the memory that is available for dynamically creating new objects while
 a program is executing, e.g., if you create a new object in R or call 
\emph on
new
\emph default
 in C++.
 When more memory is needed the program can request more from the operating
 system.
 When objects are removed in R, R will handle the garbage collection of
 releasing that memory.
\end_layout

\begin_layout Standard
The 
\emph on
stack
\emph default
 is the memory used for local variables when a function is called.
 
\end_layout

\begin_layout Standard
There's a nice discussion of this on 
\begin_inset CommandInset href
LatexCommand href
name "this Stack Overflow thread"
target "https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Hidden uses and hidden savings of memory
\end_layout

\begin_layout Subsubsection
Using inspect() to understand storage and memory use for data structures
\end_layout

\begin_layout Standard
We can use an internal function called 
\emph on
inspect()
\emph default
 to see where in memory an object is stored.
 We'll see that this can be a handy tool for seeing where copies are made
 and where they are not.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

inspect-intro
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
How lists are stored
\end_layout

\begin_layout Standard
Here we can use 
\emph on
inspect()
\emph default
 to see how the overall list is stored as well as the elements of the list
 and the attributes of the list.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

inspect
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
pryr
\emph default
 package provides 
\emph on
address()
\emph default
 or 
\emph on
inspect()
\emph default
 as an alternative to 
\emph on
.Internal(inspect())
\emph default
 though as we see here it doesn't give us the richness of information about
 complicated objects that 
\emph on
inspect()
\emph default
 does.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

pryr-address
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similar tricks are used for storing character vectors.
\end_layout

\begin_layout Subsubsection
Replacement functions
\end_layout

\begin_layout Itemize
Replacement functions can hide the use of additional memory.
 How much memory is used here? (Try running in R (not RStudio) on your own
 computer and note the 
\emph on
max_used
\emph default
 column in the 
\emph on
gc()
\emph default
 result should increase, indicating a copy was made.)
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

hidden1, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Not all replacement functions actually involve creating a new object and
 replacing the original object.
 (However for some reason if I run the code via knitr in creating this PDF
 a copy IS made.) Here `[<-` is a primitive function, so the modification
 of the vector can be done without a copy.
 Try it in R (not RStudio) on your own computer.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

hidden2, eval=TRUE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fast representations of sequences
\end_layout

\begin_layout Standard
As of R 3.5.0, 
\family typewriter
1:n
\family default
 is not stored in memory as a vector of length 
\emph on
n
\emph default
, but rather is represented by the first and last value in the sequence.
 However, some of the functions we use to determine object size don't give
 us the right answer in this case.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

sequences
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
One implication is that in older versions of R, indexing large subsets can
 involve a lot of memory use.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

hidden3, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, in older versions of R, more memory is used than just for
 
\emph on
x
\emph default
 and 
\emph on
y
\emph default
, because the index sequence itself uses a bunch of memory.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
object.size and object_size fail here
\end_layout

\begin_layout Plain Layout
mem_used and mem_change work correctly
\end_layout

\begin_layout Plain Layout
serialize expands it out...
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Delayed copying (copy-on-change) 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Lazy-evaluation,-delayed"

\end_inset


\end_layout

\begin_layout Standard
Next we'll see that something like lazy evaluation occurs outside of functions
 as well with some functionality called 
\emph on
delayed copying
\emph default
 or 
\emph on
copy-on-change
\emph default
.
 When we discussed R as being call-by-value in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Approaches-to-passing"

\end_inset

, copy-on-change was one of the reasons that copies of arguments are not
 always made.
 (But we didn't talk about it at that time.)
\end_layout

\begin_layout Standard
Let's see what goes on within a function in terms of memory use in different
 situations.
 Ignore the 
\emph on
gc()
\emph default
 results in the pdf, as we'll start R fresh to get a clean view of memory
 use during the class demo.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

copy-on-change-fun, eval=TRUE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see that 
\emph on
y
\emph default
, the local 
\emph on
x
\emph default
, and 
\emph on
out
\emph default
 all use the same memory, so no copies are made here.
 Note that in this example, if you use 
\emph on
address()
\emph default
 instead of 
\emph on
.Internal(inspect())
\emph default
 it's not really clear what is going on.
\end_layout

\begin_layout Standard
In fact, this occurs outside function calls as well.
 Copies of objects are not made until one of the objects is actually modified.
 Initially, the copy points to the same memory location as the original
 object.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

copy-on-change, eval=TRUE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or we can see this using 
\emph on
mem_change()
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

copy-mem-change-question, eval=TRUE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: explain the results of the example above.
\end_layout

\begin_layout Paragraph
How does copy-on-change work?
\end_layout

\begin_layout Standard
R keeps track of how many names refer to an object and only makes copies
 as needed when multiple names refer to an object.
 Note the value of REF and the address returned by 
\emph on
.Internal(inspect())
\emph default
, or simply use 
\emph on
refs()
\emph default
 and 
\emph on
address()
\emph default
 from 
\emph on
pryr
\emph default
.
 
\end_layout

\begin_layout Standard
We'll see this live in class.
 Unfortunately both knitting and RStudio can give us confusing results,
 so I'm adding the clean results from just running in R here in comments.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

named-r4, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In older versions of R (before R 4.0) there were some shortcomings in how
 R managed this, and one could see different results than shown below.
 
\end_layout

\begin_layout Paragraph
How can can copy-on-change be fooled in older versions of R? (Optional)
\end_layout

\begin_layout Standard
In older versions of R (before R 4.0), the mechanism for determining whether
 two names refer to the same object was simplistic.
 As discussed by Radford Neal, who has worked to improve the efficiency
 of R in a project called pqR, 
\emph on

\begin_inset Quotes eld
\end_inset

So R doesn’t copy all the time.
 Instead, it maintains a count, called NAMED, of how many “names” refer
 to an object, and copies only when an object that needs to be modified
 is also referred to by another name.
 Unfortunately, however, this scheme works rather poorly.
 Many unnecessary copies are still made, while many bugs have arisen in
 which copies aren’t made when necessary.
\emph default

\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
If you're using an older version of R, you can view the NAMED count either
 via 
\emph on
.Internal(inspect())
\emph default
 or by using 
\emph on
pryr::refs()
\emph default
.
\end_layout

\begin_layout Subsection
Deep copies and lists and character strings
\end_layout

\begin_layout Standard
Prior to R 3.1.0, modifying an element of a list caused the entire list to
 be copied, basically what is called a 
\emph on
deep copy
\emph default
.
 In more recent versions of R, only the components that need to get copied
 are copied.
 
\end_layout

\begin_layout Standard
You can explore this using 
\emph on
.Internal(inspect())
\emph default
 on a list.
\end_layout

\begin_layout Standard
R is also clever about saving copying when it works with character strings.
 Character vectors are handled in a similar way as lists.
\end_layout

\begin_layout Subsection
Passing objects to compiled code (optional)
\end_layout

\begin_layout Standard
This subsection is out-of-date and doesn't reflect that most people these
 days use the 
\emph on
Rcpp
\emph default
 package rather than the older .C and .Call interfaces to compiled code.
 We won't cover this subsection in class and don't expect you to know this
 material.
 However, if you do end up interfacing to external code, thinking about
 whether copies are made when calling out to external code can be important
 if you're working with large objects.
\end_layout

\begin_layout Standard
As we've already discussed, when R objects are passed to compiled code (e.g.,
 C or C++), they are passed as pointers and the compiled code uses the memory
 allocated by R (though it could also allocate additional memory if allocation
 is part of the code).
 However, a copy of the object is made, so when calling a C function from
 R there is some memory overhead.
 (However, a previous GSI commented to me that in Rcpp, one can pass by
 reference and avoid having copies made.)
\end_layout

\begin_layout Standard
Furthermore, we need to be aware of any casting that occurs, because the
 compiled code requires that the R object types match those that the function
 in the compiled code is expecting.
 
\end_layout

\begin_layout Standard
Here's an example of calling compiled code:
\end_layout

\begin_layout Standard

\family typewriter
res <- .C("fastcount", PACKAGE="GCcorrect", tablex = as.integer(tablex),
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

tabley = as.integer(tabley), as.integer(xvar), as.integer(yvar),
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

as.integer(useline), as.integer(length(xvar)))
\end_layout

\begin_layout Standard
Let's consider when copies are made in casts:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

casts, eval=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next we'll see that C calls do involve a copy, even though it looks like
 we are just using the same object allocated by R.
 We'll use the 
\emph on
inline
\emph default
 package to work directly with C code in R and the .C functionality for interfaci
ng with C.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

pass-to-C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Strategies for saving memory
\end_layout

\begin_layout Standard
A couple basic strategies for saving memory include:
\end_layout

\begin_layout Itemize
Avoiding unnecessary copies.
\end_layout

\begin_layout Itemize
Removing objects that are not being used and, if necessary (not generally
 needed), do a 
\emph on
gc()
\emph default
 call.
\end_layout

\begin_layout Standard
If you're really trying to optimize memory use, you may also consider:
\end_layout

\begin_layout Itemize
Using R6 classes and similar strategies to pass by reference.
\end_layout

\begin_layout Itemize
Substituting integer and logical vectors for numeric vectors when possible.
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
Let's work through a real example where we keep a running tally of current
 memory in use and maximum memory used in a function call.
 We'll want to consider hidden uses of memory, when copies are made, and
 lazy evaluation.
 (In a real example we'd also want to think about when copies are made in
 calling compiled code, but we don't do that in class.) This code is courtesy
 of Yuval Benjamini.
 For our purposes here, let's assume that 
\emph on
xvar
\emph default
 and 
\emph on
yvar
\emph default
 are very long vectors using a lot of memory.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

memuse-real, eval = FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Computing on the language (optional)
\begin_inset CommandInset label
LatexCommand label
name "sec:Computing-on-the"

\end_inset


\end_layout

\begin_layout Standard
We won't cover much, if any, of this section and I won't expect you to know
 this material, but some of you may find it interesting.
 Also, when I talked about R being a particularly flexible language in explainin
g in part why R can be slow, much of that flexibility is illustrated here.
 
\end_layout

\begin_layout Subsection
The R interpreter
\end_layout

\begin_layout Paragraph
Parsing
\end_layout

\begin_layout Standard
When you run R, the R interpreter takes the code you type or the lines of
 code that are read in a batch session and parses each statement, translating
 the text into functional form.
 It substitutes objects for the symbols (names) that represent those objects
 and evaluates the statement, returning the resulting object.
 For complicated R code, this may be recursive.
\end_layout

\begin_layout Standard
Since everything in R is an object, the result of parsing is an object that
 we'll be able to investigate, and the result of evaluating the parsed statement
 is an object.
\end_layout

\begin_layout Standard
We'll see more on parsing in the next section.
\end_layout

\begin_layout Paragraph

\emph on
.Primitive()
\emph default
 and 
\emph on
.Internal()
\emph default
 (and 
\emph on
.External
\emph default
())
\end_layout

\begin_layout Standard
Some functionality is implemented internally within the C implementation
 that lies at the heart of R.
 If you see 
\emph on
.Internal()
\emph default
 or 
\emph on
.Primitive()
\emph default
 or 
\emph on
.External()
\emph default
, in the code of a function, you know it's implemented internally (and therefore
 generally very quickly).
 Unfortunately, it also means that you don't get to see R code that implements
 the functionality, though Chambers p.
 465 describes how you can look into the C source code.
 Basically you need to download the source code for the relevant package
 off of CRAN.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

internal-funs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parsing code and understanding language objects
\end_layout

\begin_layout Standard
R code can be manipulated in text form and we can actually write R code
 that will create or manipulate R code.
 We can then evaluate that R code using 
\emph on
eval()
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
quote()
\emph default
 will parse R code, but not evaluate it.
 This allows you to work with the code rather than the results of evaluating
 that code.
 The 
\emph on
print()
\emph default
 method for language objects is not very helpful! But we can see the parsed
 code by treating the result as a list.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

quote, tidy=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Recall that to access symbols that involve special syntax (such as special
 characters), you use backquotes.
\end_layout

\begin_layout Standard
Officially, the name that you assign to an object (including functions)
 is a 
\emph on
symbol
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

type-quote
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can create an 
\emph on
expression
\emph default
 object that contains R code as
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The difference between 
\emph on
quote()
\emph default
 and 
\emph on
expression()
\emph default
 is basically that 
\emph on
quote()
\emph default
 works with a single statement (including multiple statements inside {...}),
 while 
\emph on
expression()
\emph default
 can deal with multiple statements, returning a list-like object of parsed
 statements.
 Both of them parse R code.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

parsing
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following table shows the 
\emph on
language
\emph default
 objects in R; note that there are three classes of language objects: 
\emph on
expressions
\emph default
, 
\emph on
calls
\emph default
, and 
\emph on
names
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Example syntax to create
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
object names
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(x)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
symbol (language)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expressions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression(x <- 3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expression (language)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function calls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(f())
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if statements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(if(x < 3) y=5)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if (call)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
for statement
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(for(i in 1:5) {})
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
for (call)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assignments
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(x <- 3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<- (call)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
operators
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote(3 + 7)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
language
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset

Basically any standard function, operator, 
\emph on
if
\emph default
 statement, 
\emph on
for
\emph default
 statement, assignment, etc.
 are function calls and inherit from the 
\emph on
call
\emph default
 class.
 
\end_layout

\begin_layout Standard
Objects of type language are not officially lists, but they can be queried
 as such.
 You can convert between language objects and lists with 
\emph on
as.list()
\emph default
 and 
\emph on
as.call()
\emph default
.
 
\end_layout

\begin_layout Standard
An official expression is one or more syntactically correct R statements.
 When we use 
\emph on
quote()
\emph default
, we're working with a single statement, while 
\emph on
expression()
\emph default
 will create a list of separate statements (essentially separate call objects).
 I'm trying to use the term 
\emph on
statement
\emph default
 to refer colloquially to R code, rather than using the term 
\emph on
expression
\emph default
, since that has formal definition in this context.
\end_layout

\begin_layout Standard
Let's take a look at some examples of language objects and parsing.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

lang-objects, tidy=FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can evaluate language types using 
\emph on
eval()
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

eval-lang
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now let's look in more detail at the components of R expressions.
 We'll be able to get a sense from this of how R evaluates code.
 We see that when R evaluates a parse tree, the first element says what
 function to use and the remaining elements are the arguments.
 But in many cases one or more arguments will themselves be call objects,
 so there's recursion.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

expr-structure
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Manipulating the parse tree
\end_layout

\begin_layout Standard
Of course since the parsed code is just an object, we can manipulate it,
 i.e., 
\emph on
compute on the language
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

manip-expr
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here's another example:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

manip-expr2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also turn it back into standard R code, as a character, using 
\emph on
deparse()
\emph default
, which turns the parse tree back into R code as text.
 
\emph on
parse()
\emph default
 is like 
\emph on
quote()
\emph default
 but it takes the code in the form of a string rather than an actual expression:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

deparse
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the quotes have been escaped since they're inside a string.
\end_layout

\begin_layout Standard
It can be very useful to be able to convert names of objects that are in
 the form of text to names that R interprets as symbols referring to objects:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

manip-names
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Parsing replacement expressions
\end_layout

\begin_layout Standard
Let's consider replacement expressions.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

replace-lang
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The parse tree for 
\emph on
out3
\emph default
 is different than those for 
\emph on
out1
\emph default
 and 
\emph on
out2
\emph default
, but when 
\emph on
out3
\emph default
 is evaluated the result is the same as for 
\emph on
out1
\emph default
 and 
\emph on
out2
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

replace-lang2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why? When R evaluates a call to `<-`, if the first argument is a name, then
 it does the assignment, but if the first argument (i.e.
 what's on the left-hand side of the 
\begin_inset Quotes eld
\end_inset

assignment
\begin_inset Quotes erd
\end_inset

) is a call then it calls the appropriate replacement function.
 The second argument (the value being assigned) is evaluated first.
 Ultimately in all of these cases, the replacement function is used.
\end_layout

\begin_layout Subsection
substitute()
\end_layout

\begin_layout Standard
The substitute function acts like 
\emph on
quote()
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

substitute
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
But if you also pass 
\emph on
substitute()
\emph default
 an environment, it will replace symbols with their object values in that
 environment.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

substitute2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This can do non-sensical stuff:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

crazy-subst
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's see a practical example of substituting for variables in statements:
\end_layout

\begin_layout Standard

\family typewriter
plot(x = rnorm(5), y = rgamma(5, 1)) # how does plot get the axis label
 names?
\family default

\begin_inset Newline newline
\end_inset

In the 
\emph on
plot()
\emph default
 function, you can see this syntax:
\end_layout

\begin_layout Standard

\family typewriter
xlabel <- if(!missing(x)) deparse(substitute(x))
\family default

\begin_inset Newline newline
\end_inset

So what's going on is that within 
\emph on
plot.default()
\emph default
, it substitutes in for '
\emph on
x
\emph default
' with the statement that was passed in as the 
\emph on
x
\emph default
 argument, and then uses 
\emph on
deparse()
\emph default
 to convert to character.
 The fact that 
\emph on
x
\emph default
 still has 
\emph on
rnorm(5)
\emph default
 associated with it rather than the five numerical values from evaluating
 
\emph on
rnorm()
\emph default
 has to do with lazy evaluation and promises.
 Here's the same idea in action in a stripped down example:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

subst-example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
More generally, we can substitute into 
\emph on
expression
\emph default
 and 
\emph on
call
\emph default
 objects by providing a named list (or an environment) - the substition
 happens within the context of this list.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

subst3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Things can get intricate quickly:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

subst4
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem is that 
\emph on
substitute()
\emph default
 doesn't evaluate its first argument, 
\begin_inset Quotes eld
\end_inset


\emph on
e1
\emph default

\begin_inset Quotes erd
\end_inset

, so it can't replace the parsed elements in 
\emph on
e1
\emph default
.
 Instead, we'd need to do the following, where we force the evaluation of
 
\emph on
e1
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

double-subst
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If this subsection is confusing, let me assure you that it has confused
 me too.
 The indirection going on here is very involved.
\end_layout

\begin_layout Subsection
Final thoughts
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: figure out how a 
\emph on
for
\emph default
 loop is parsed in R.
 See how a 
\emph on
for
\emph default
 loop with one statement within the loop differs from one with two or more
 statements.
\end_layout

\begin_layout Standard
We'll see 
\emph on
expression()
\emph default
 again when we talk about inserting mathematical notation in plots.
\end_layout

\end_body
\end_document
